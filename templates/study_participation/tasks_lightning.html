{% extends "base.html" %}
{% block title %}{{ study.title }} - Tasks{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/study_participation.css') }}">
<style>
/* Remove top space and colored bars for tasks page */
body {
    margin: 0 !important;
    padding: 0 !important;
    overflow: hidden !important; /* Prevent scrolling */
    height: 100vh !important; /* Force full viewport height */
    /* Dark brown background */
}

/* Override main content top margin and padding */
#main-content.app-main {
    margin: 0 !important;
    padding: 0 !important;
    background: transparent !important;
    overflow: hidden !important; /* Prevent scrolling */
    height: 100vh !important; /* Force full viewport height */
}

/* Remove any top bars or spacing */
.app-header,
.progress-section,
.flash-container {
    display: none !important;
}

/* Ensure countdown takes full screen */
.image-countdown {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
}

/* Task container should start from top */
.task-container {
    margin-top: 0 !important;
    padding-top: 0 !important;
    overflow: hidden !important; /* Prevent scrolling */
    height: 100vh !important; /* Force full viewport height */
}

/* Global scroll prevention */
* {
    box-sizing: border-box;
}

html, body {
    overflow: hidden !important;
    height: 100vh !important;
    width: 100vw !important;
}

/* Use calculated viewport height for better mobile support */
:root {
    --vh: 1vh;
    --vw: 1vw;
}

/* Force exact screen dimensions */
html, body, #main-content, .task-container {
    height: calc(var(--vh, 1vh) * 100) !important;
    width: calc(var(--vw, 1vw) * 100) !important;
    overflow: hidden !important;
}

/* Progress bar removed - no more top space */
/* Lightning-fast task transitions */
.task-container {
    transition: opacity 0.2s ease-in-out;
}

.task-container.fade-out {
    opacity: 0;
}

.task-container.fade-in {
    opacity: 1;
}

/* Progress bar removed - too big */

/* Modern UI - Card-based layout like 3rd image */
body {
  
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* Main task card */
.task-card {
    background: white;
    border-radius: 2vh;
    padding: 1vh;
    margin: 0 0.5vh 0.5vh 0.5vh;
    box-shadow: 0 0.4vh 2vh rgba(0,0,0,0.15);
    height: calc(calc(var(--vh, 1vh) * 99) - 1vh); /* 99vh minus margins */
    overflow: hidden; /* Prevent content overflow */
    box-sizing: border-box; /* Include padding in height calculation */
}

/* Progress indicator - Instagram stories style with individual rectangles */
.progress-indicator {
    background: transparent; /* No background for the container */
    border-radius: 1vh;
    text-align: center;
    font-weight: 500;
    font-size: 1.4vh;
    position: relative;
    overflow: visible;
    min-width: 20vw;
    display: block;
    height: auto;
    padding: 1.5vh 0 0.5vh 0;
    margin: 1vh auto;
}

/* Task rectangles container */
.task-rectangles {
    display: flex;
    gap: 0.4vh;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    max-width: 100%;
}

/* Individual task rectangle */
.task-rectangle {
    width: 1.2vh;
    height: 0.8vh;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 0.2vh;
    transition: all 0.3s ease-in-out;
    border: 0.1vh solid rgba(255, 255, 255, 0.2);
}

/* Completed task rectangle */
.task-rectangle.completed {
    background: linear-gradient(90deg, #4CAF50, #45a049);
    border-color: #4CAF50;
    transform: scale(1.1);
    box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
}

/* Current task rectangle */
.task-rectangle.current {
    background: linear-gradient(90deg, #FF9800, #F57C00);
    border-color: #FF9800;
    transform: scale(1.2);
    box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
    animation: pulse 1.5s ease-in-out infinite;
}

/* Upcoming task rectangle */
.task-rectangle.upcoming {
    background: lightgrey;
    border-color: #D3D3D3;
    opacity: 0.8;
}

/* Progress indicator text */
.progress-indicator .progress-text {
    position: absolute;
    top: -20px; /* Position text above the bar */
    right: 0;
    color: #1976D2;
    font-weight: 600;
    font-size: 12px;
    z-index: 2;
}



/* Question text */
.question-text {
    font-size: 2.2vh;
    font-weight: 700;
    color: #333;
    margin-bottom: 0.6vh;
    text-align: center;
}

/* Image container */
.image-container {
    text-align: center;
    margin-bottom: 0.5vh;
    height: calc(calc(var(--vh, 1vh) * 60) - 2vh); /* 60vh minus margins */
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* Prevent image overflow */
}

.task-image {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    border-radius: 15px;
    box-shadow: none !important;
    border: none !important;
    object-fit: contain;
}

/* Grid elements container for grid studies */
.grid-elements-container {
    display: flex;

    justify-content: center;
    align-items: flex-start;
    gap: 1rem;
    padding: 1rem;
    background: #f8fafc;
    border-radius: 12px;
    border: 1px solid #e2e8f0;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    /* Ensure grid elements don't interfere with rating options */
    position: relative;
    z-index: 1;
}

.grid-element-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    background: white;
    padding: 0.75rem;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.grid-image {
    width: 100%;
    max-width: 180px;
    height: auto;
    margin-bottom: 0.5rem;
    border-radius: 8px;
}

.element-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: #475569;
    background: #f1f5f9;
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    border: 1px solid #e2e8f0;
}

.no-elements-message {
    text-align: center;
    padding: 2rem;
    color: #64748b;
    font-style: italic;
    background: #f1f5f9;
    border-radius: 8px;
    border: 1px dashed #cbd5e1;
}

/* Vignette preview for layer studies */
.vignette-preview {
    border: none !important;
    box-shadow: none !important;
    background: none !important;
    position: relative;
    width: 100%;
    height: calc(calc(var(--vh, 1vh) * 65) - 1vh); /* 55vh minus margins */
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* Prevent overflow */
}

.layer-image {
    border: none !important;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 100%;
    max-height: 100%;
}

.vignette-layer-img {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    border-radius: 15px;
    box-shadow: none !important;
    border: none !important;
    object-fit: contain;
}

/* Rating section */
.rating-section {
    background: white;
    border-radius: 1.5vh;
    padding: 2vh 1.5vh 1.5vh 1.5vh; /* More top padding to prevent cut-off */
    box-shadow: 0 0.2vh 1vh rgba(0,0,0,0.05);
    margin-top: 1vh; /* Add top margin for breathing room */
    overflow: visible; /* Allow rating circles to be fully visible */
    min-height: 15vh; /* Ensure minimum height for rating section */
    /* Ensure rating section is above content but below loader */
    position: relative !important;
    z-index: 50 !important;
}

.rating-instructions {
    display: flex;
    gap: 1vh;
    flex-direction: row;
    justify-items: center;
    justify-content: center;
    text-align: center;
    margin-bottom: 1.5vh; /* Add bottom margin for spacing */
    color: #666;
    font-size: 1.3vh;
}

.rating-instructions p {
    
    font-weight: 500;
}

.rating-grid {
    margin: 0 !important;
    padding: 1vh 0 !important; /* Add vertical padding to prevent cut-off */
    display: flex;
    justify-content: center;
    gap: 1.2vh;
    flex-wrap: wrap;
    align-items: center; /* Ensure proper vertical alignment */
}

.rating-option {
    cursor: pointer !important;
    transition: all 0.2s ease;
    position: relative !important;
    z-index: 50 !important; /* Balanced z-index - above content but below loader */
    pointer-events: auto !important;
    user-select: none;
    /* Ensure the rating option is clickable */
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    background: transparent !important;
    /* Force rating options to be clickable */
    position: relative !important;
    z-index: 999 !important; /* Higher z-index for grid studies */
}

/* Specific fix for grid studies */
.grid-elements-container + .rating-section .rating-option {
    z-index: 999 !important;
    pointer-events: auto !important;
    position: relative !important;
}

/* Ensure grid elements don't interfere with ratings */
.grid-elements-container {
    pointer-events: none !important;
}

.grid-elements-container img {
    pointer-events: none !important;
}

.grid-elements-container .element-label {
    pointer-events: none !important;
}

.rating-label {
    width: 5vh;
    height: 5vh;
    border: 0.2vh solid #E0E0E0;
    border-radius: 2.5vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    font-weight: 600;
    font-size: 1.6vh;
    color: #333;
    transition: all 0.2s ease;
}

.rating-label:hover {
    border-color: #E0E0E0;
    background: #F5F5F5;
    transform: scale(1.05);
}

.rating-label.active {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
    transform: scale(1.1);
    z-index: 10; /* Ensure active rating is on top */
    position: relative; /* Create stacking context */
}

/* Task navigation removed - only top progress bar remains */

/* Rating submission feedback */
.rating-feedback {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #4CAF50;
    color: white;
    padding: 20px 40px;
    border-radius: 15px;
    font-size: 18px;
    font-weight: bold;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.3s ease;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}

.rating-feedback.show {
    opacity: 1;
}

/* Image Loading Countdown */
.image-countdown {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    font-family: 'Arial', sans-serif;
    margin: 0 !important;
    padding: 0 !important;
}

.countdown-content {
    text-align: center;
    color: white;
}

.countdown-number {
    font-size: 12vh;
    font-weight: bold;
    margin-bottom: 2vh;
    text-shadow: 0 0 2vh rgba(255, 255, 255, 0.5);
    animation: pulse 1s ease-in-out infinite;
}

.countdown-text {
    font-size: 3.6vh;
    font-weight: bold;
    margin-bottom: 1.5vh;
    text-transform: uppercase;
    letter-spacing: 0.2vh;
    text-shadow: 0 0 1.5vh rgba(255, 255, 255, 0.3);
}

.countdown-subtext {
    font-size: 1.8vh;
    opacity: 0.9;
    text-shadow: 0 0 1vh rgba(255, 255, 255, 0.2);
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Study completion loader */
.completion-loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.completion-loader.show {
    opacity: 1;
    visibility: visible;
}

.loader-spinner {
    width: 60px;
    height: 60px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #4CAF50;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loader-text {
    color: white;
    font-size: 18px;
    font-weight: 500;
    text-align: center;
    margin-bottom: 10px;
}

.loader-subtext {
    color: #ccc;
    font-size: 14px;
    text-align: center;
    max-width: 300px;
    line-height: 1.4;
}

/* Loading states */
.loading {
    opacity: 0.7;
    pointer-events: none;
}

/* Responsive design */
@media (max-width: 480px) {
    .task-card {
        margin: 0 10px 10px 10px;
        padding: 15px;
        min-height: 90vh;
    }
    
    .question-text {
        font-size: 16px;
    }
    
    .image-container {
        height: 65vh;
    }
    
    .rating-section {
        padding: 12px;
    }
    
    /* Mobile progress indicator adjustments */
.progress-indicator {
    margin: 0 !important;
    min-width: 15vw;
    padding: 1vh 0 0.3vh 0;
}

.task-rectangles {
    gap: 0.3vh;
}

.task-rectangle.upcoming {
    background: lightgrey;
    border-color: #D3D3D3;
}

.task-rectangle {
    width: 1vh;
    height: 0.6vh;
}

.progress-text {
    font-size: 1.1vh;
    top: -1.8vh;
}
}
</style>
{% endblock %}

{% block content %}
<!-- Progress bar removed - too big -->

<!-- Task container -->
<div class="task-container" id="taskContainer">
    <!-- Tasks will be dynamically loaded here -->
</div>

<!-- Rating feedback -->
<div class="rating-feedback" id="ratingFeedback">
    ✓ Task Completed!
</div>

    <!-- Image Loading Countdown -->
    <div id="imageCountdown" class="image-countdown">
        <div class="countdown-content">
            <div class="countdown-number" id="countdownNumber">3</div>
            <div class="countdown-text" id="countdownText">GET READY!</div>
            <div class="countdown-subtext" id="countdownSubtext">Loading your first task...</div>
            <button id="manualCountdownBtn" style="margin-top: 20px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Start Countdown Manually</button>
        </div>
    </div>

<!-- Study completion loader -->
<div class="completion-loader" id="completionLoader">
    <div class="loader-spinner"></div>
    <div class="loader-text">Completing Your Study...</div>
    <div class="loader-subtext">Please wait while we save your responses and prepare your completion page.</div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Lightning-fast task flow - all tasks loaded upfront with image preloading
class LightningTaskFlow {
    constructor(studyId, totalTasks, allTasks) {
        this.studyId = studyId;
        this.totalTasks = totalTasks;
        this.allTasks = allTasks;
        this.currentTaskIndex = 0;
        this.taskRatings = [];
        this.isSubmitting = false;
        this.preloadedImages = new Map();
        
        // Initialize
        this.init();
    }
    
    init() {
        console.log('🚀 Lightning Task Flow initialized!');
        console.log(`Total tasks: ${this.totalTasks}`);
        console.log('All tasks loaded:', this.allTasks);
        console.log('🔍 First task structure:', this.allTasks[0]);
        console.log('🔍 First task elements_shown:', this.allTasks[0]?.elements_shown);
        
        // Debug task data structure for grid studies
        if (this.allTasks && this.allTasks.length > 0) {
            const firstTask = this.allTasks[0];
            console.log('🔍 FIRST TASK DETAILED ANALYSIS:');
            console.log('- Task keys:', Object.keys(firstTask));
            console.log('- Task type:', typeof firstTask);
            console.log('- elements_shown type:', typeof firstTask.elements_shown);
            console.log('- elements_shown:', firstTask.elements_shown);
            
            if (firstTask.elements_shown) {
                console.log('- elements_shown entries:', Object.entries(firstTask.elements_shown));
                console.log('- elements_shown length:', Object.keys(firstTask.elements_shown).length);
                
                // Check for grid study specific structure
                const contentKeys = Object.keys(firstTask.elements_shown).filter(key => key.endsWith('_content'));
                const elementKeys = Object.keys(firstTask.elements_shown).filter(key => !key.endsWith('_content'));
                
                console.log('- Content keys (ending with _content):', contentKeys);
                console.log('- Element keys (not ending with _content):', elementKeys);
                
                contentKeys.forEach(key => {
                    const baseKey = key.replace('_content', '');
                    const content = firstTask.elements_shown[key];
                    const isActive = firstTask.elements_shown[baseKey];
                    console.log(`  • ${key} -> ${baseKey}: content="${content}", active=${isActive}`);
                });
            }
        }
        
        // Calculate and apply screen dimensions
        this.calculateAndApplyDimensions();
        
        // Show countdown immediately
        this.showImageCountdown();
        
        // Start countdown immediately (don't wait for images)
        console.log('🎯 About to call startCountdown()...');
        
        // Simple countdown test first
        this.testSimpleCountdown();
        
        // Then try the full countdown
        this.startCountdown();
        console.log('✅ startCountdown() called successfully!');
        
        // Add manual countdown test after 5 seconds if it doesn't work
        // BUT ONLY if we're still on the countdown screen
        setTimeout(() => {
            // Check if we're still on the countdown screen (not showing tasks)
            const countdownElement = document.getElementById('countdownContainer');
            const taskContainer = document.getElementById('taskContainer');
            
            if (countdownElement && countdownElement.style.display !== 'none' && 
                (!taskContainer || taskContainer.children.length === 0)) {
                console.log('🔄 Manual countdown test after 5 seconds...');
                this.manualCountdownTest();
            } else {
                console.log('✅ Manual countdown test skipped - tasks already in progress');
            }
        }, 5000);
        
        // Add manual button listener
        this.setupManualButton();
        
        // Preload images for first few tasks
        this.preloadInitialImages();
        
        // Generate navigation
        this.generateNavigation();
        
        // Update progress
        this.updateProgress();
        
        // Initialize local storage
        this.loadFromLocalStorage();
    }
    
    calculateAndApplyDimensions() {
        const vh = window.innerHeight * 0.01;
        const vw = window.innerWidth * 0.01;
        
        console.log('📱 TaskFlow Screen dimensions:', {
            innerHeight: window.innerHeight,
            innerWidth: window.innerWidth,
            vh: vh,
            vw: vw
        });
        
        // Set CSS custom properties
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        document.documentElement.style.setProperty('--vw', `${vw}px`);
        
        // Force recalculation of layout
        this.updateLayoutDimensions();
    }
    
    updateLayoutDimensions() {
        const taskCard = document.querySelector('.task-card');
        if (taskCard) {
            const cardHeight = window.innerHeight - 2; // 2px for margins
            taskCard.style.height = `${cardHeight}px`;
            console.log(`✅ Task card height set to: ${cardHeight}px`);
        }
    }
    
    preloadInitialImages() {
        console.log('🖼️  ULTRA-FAST preloading for first task...');
        
        // Get first task images immediately
        const firstTask = this.allTasks[0];
        if (!firstTask) {
            console.error('❌ No first task found!');
            return;
        }
        
        const firstTaskImages = new Set();
        this.extractImageUrls(firstTask, firstTaskImages);
        
        console.log(`📸 First task has ${firstTaskImages.size} images - loading with MAXIMUM priority`);
        
        // Load first task images with multiple techniques for speed
        firstTaskImages.forEach((url, index) => {
            // Use multiple preloading techniques for first image
            this.preloadImageUltraFast(url, index === 0);
        });
        
        // Start loading other tasks in background
        setTimeout(() => {
            this.preloadRemainingTasks();
        }, 50);
    }
    
    preloadRemainingTasks() {
        console.log('🔄 Preloading remaining tasks in background...');
        
        // Load images for tasks 2-5
        for (let i = 1; i < Math.min(5, this.totalTasks); i++) {
            const task = this.allTasks[i];
            if (task) {
                const imageUrls = new Set();
                this.extractImageUrls(task, imageUrls);
                imageUrls.forEach(url => {
                    this.preloadImage(url);
                });
            }
        }
    }
    
    preloadNextTaskImages() {
        const nextTaskIndex = this.currentTaskIndex + 1;
        if (nextTaskIndex < this.totalTasks) {
            console.log(`🔄 Preloading images for next task: ${nextTaskIndex + 1}`);
            const nextTask = this.allTasks[nextTaskIndex];
            if (nextTask) {
                const imageUrls = new Set();
                this.extractImageUrls(nextTask, imageUrls);
                
                console.log(`📸 Preloading ${imageUrls.size} images for next task`);
                imageUrls.forEach(url => {
                    this.preloadImage(url);
                });
            }
        }
    }
    
    extractImageUrls(task, imageUrls) {
        const studyType = '{{ study.study_type }}';
        
        if (studyType === 'grid') {
            // Grid study images
            if (task.elements_shown) {
                for (const [elementName, elementData] of Object.entries(task.elements_shown)) {
                    if (elementName.endsWith('_content') && elementData && elementData !== '') {
                        imageUrls.add(elementData);
                    }
                }
            }
        } else if (studyType === 'layer') {
            // Layer study images
            if (task.elements_shown_content) {
                for (const [elementName, elementData] of Object.entries(task.elements_shown_content)) {
                    if (elementData && elementData !== 'none' && elementData !== '' && typeof elementData === 'object') {
                        if (elementData.url) {
                            imageUrls.add(elementData.url);
                        }
                    }
                }
            }
        }
    }
    
    preloadImage(url) {
        if (this.preloadedImages.has(url)) {
            return; // Already preloaded
        }
        
        console.log(`🔄 Preloading image: ${url}`);
        
        const img = new Image();
        img.onload = () => {
            console.log(`✅ Image preloaded successfully: ${url}`);
            this.preloadedImages.set(url, img);
        };
        img.onerror = () => {
            console.log(`❌ Failed to preload image: ${url}`);
        };
        img.src = url;
    }
    
    preloadImageUltraFast(url, isFirstImage = false) {
        if (this.preloadedImages.has(url)) {
            return; // Already preloaded
        }
        
        console.log(`⚡ ULTRA-FAST preloading: ${url} ${isFirstImage ? '(FIRST IMAGE - MAX PRIORITY)' : ''}`);
        
        const img = new Image();
        
        // Maximum priority for first image
        if (isFirstImage) {
            img.loading = 'eager';
            img.decoding = 'sync';
            img.fetchPriority = 'high';
            console.log(`🚀 Setting MAXIMUM priority for first image: ${url}`);
        }
        
        img.onload = () => {
            console.log(`✅ ULTRA-FAST image loaded: ${url}`);
            this.preloadedImages.set(url, img);
            
            // If this was the first image, start loading all other images
            if (isFirstImage) {
                console.log('🎯 First image loaded! Now starting to load ALL other images...');
                this.preloadAllRemainingImages();
            }
        };
        
        img.onerror = () => {
            console.log(`❌ Failed to load image: ${url}`);
        };
        
        img.src = url;
    }
    
    showImageCountdown() {
        console.log('🎮 Showing game-style countdown while images load...');
        const countdown = document.getElementById('imageCountdown');
        countdown.style.display = 'flex';
    }
    
    hideImageCountdown() {
        console.log('✅ Hiding countdown, showing first task...');
        const countdown = document.getElementById('imageCountdown');
        countdown.style.display = 'none';
    }
    
    testSimpleCountdown() {
        console.log('🧪 Testing simple countdown...');
        
        const countdownNumber = document.getElementById('countdownNumber');
        if (countdownNumber) {
            console.log('✅ countdownNumber found, current text:', countdownNumber.textContent);
            
            // Test if we can update the DOM
            countdownNumber.textContent = 'TEST';
            console.log('📱 Updated to TEST, now shows:', countdownNumber.textContent);
            
            // Change back to 3
            countdownNumber.textContent = '3';
            console.log('📱 Changed back to 3, now shows:', countdownNumber.textContent);
        } else {
            console.error('❌ countdownNumber NOT found!');
        }
    }
    
    manualCountdownTest() {
        console.log('🎮 Manual countdown test - forcing countdown to work...');
        
        // CRITICAL: Check if tasks are already in progress
        if (this.currentTaskIndex > 0 || this.taskRatings.length > 0) {
            console.log('⚠️ Manual countdown test ABORTED - tasks already in progress!');
            console.log(`Current task index: ${this.currentTaskIndex}, Completed tasks: ${this.taskRatings.length}`);
            return;
        }
        
        const countdownNumber = document.getElementById('countdownNumber');
        const countdownText = document.getElementById('countdownText');
        const countdownSubtext = document.getElementById('countdownSubtext');
        
        if (countdownNumber && countdownText && countdownSubtext) {
            console.log('✅ All elements found, starting manual countdown...');
            
            // Manual countdown: 3, 2, 1, GO!
            countdownNumber.textContent = '3';
            countdownText.textContent = 'GET READY!';
            countdownSubtext.textContent = 'Starting in 3...';
            
            setTimeout(() => {
                countdownNumber.textContent = '2';
                countdownText.textContent = 'GET READY!';
                countdownSubtext.textContent = 'Starting in 2...';
                console.log('📱 Manual countdown: 2');
            }, 1000);
            
            setTimeout(() => {
                countdownNumber.textContent = '1';
                countdownText.textContent = 'GET READY!';
                countdownSubtext.textContent = 'Starting in 1...';
                console.log('📱 Manual countdown: 1');
            }, 2000);
            
            setTimeout(() => {
                countdownNumber.textContent = 'GO!';
                countdownText.textContent = 'TASK READY!';
                countdownSubtext.textContent = 'Your first task is ready!';
                console.log('📱 Manual countdown: GO!');
                
                // After 1 second, hide countdown and show first task
                setTimeout(() => {
                    this.hideImageCountdown();
                    this.showTask(0);
                }, 1000);
            }, 3000);
            
        } else {
            console.error('❌ Elements not found for manual countdown');
        }
    }
    
    setupManualButton() {
        const manualBtn = document.getElementById('manualCountdownBtn');
        if (manualBtn) {
            manualBtn.addEventListener('click', () => {
                console.log('🔘 Manual countdown button clicked!');
                this.startCountdown();
            });
            console.log('✅ Manual button listener added');
        } else {
            console.error('❌ Manual button not found');
        }
    }
    
    startCountdown() {
        console.log('🎮 Starting SIMPLE countdown: 3... 2... 1... GO!');
        
        const countdownNumber = document.getElementById('countdownNumber');
        const countdownText = document.getElementById('countdownText');
        const countdownSubtext = document.getElementById('countdownSubtext');
        
        if (!countdownNumber || !countdownText || !countdownSubtext) {
            console.error('❌ Countdown elements not found!');
            return;
        }
        
        console.log('✅ Starting simple countdown...');
        
        // Simple countdown using setTimeout instead of setInterval
        countdownNumber.textContent = '3';
        countdownText.textContent = 'GET READY!';
        countdownSubtext.textContent = 'Starting in 3...';
        console.log('📱 Showed: 3');
        
        setTimeout(() => {
            countdownNumber.textContent = '2';
            countdownText.textContent = 'GET READY!';
            countdownSubtext.textContent = 'Starting in 2...';
            console.log('📱 Showed: 2');
        }, 1000);
        
        setTimeout(() => {
            countdownNumber.textContent = '1';
            countdownText.textContent = 'GET READY!';
            countdownSubtext.textContent = 'Starting in 1...';
            console.log('📱 Showed: 1');
        }, 2000);
        
        setTimeout(() => {
            countdownNumber.textContent = 'GO!';
            countdownText.textContent = 'TASK READY!';
            countdownSubtext.textContent = 'Your first task is ready!';
            console.log('📱 Showed: GO!');
        }, 3000);
        
        setTimeout(() => {
            console.log('🎯 Countdown finished, showing first task...');
            this.hideImageCountdown();
            this.showTask(0);
        }, 4000);
        
        console.log('⏰ Simple countdown started with setTimeout');
    }
    
    preloadAllRemainingImages() {
        console.log('🔄 Loading ALL remaining images for all tasks...');
        
        const allImageUrls = new Set();
        
        // Collect all image URLs from all tasks
        for (let i = 0; i < this.totalTasks; i++) {
            const task = this.allTasks[i];
            if (task) {
                this.extractImageUrls(task, allImageUrls);
            }
        }
        
        console.log(`📸 Total unique images found: ${allImageUrls.size}`);
        
        // Load all remaining images (excluding already loaded ones)
        allImageUrls.forEach(url => {
            if (!this.preloadedImages.has(url)) {
                this.preloadImage(url);
            }
        });
    }
    
    generateNavigation() {
        // Navigation is now handled by the progress bar
        // No need to generate individual buttons
        console.log('Navigation initialized with progress bar');
    }
    
    showTask(taskIndex) {
        if (taskIndex < 0 || taskIndex >= this.totalTasks) return;
        
        this.currentTaskIndex = taskIndex;
        const task = this.allTasks[taskIndex];
        
        console.log(`🎯 Showing task ${taskIndex + 1} of ${this.totalTasks}:`, task);
        console.log(`🔍 Current task index: ${this.currentTaskIndex}`);
        
        // Debug task structure for layer studies
        if ('{{ study.study_type }}' === 'layer') {
            console.log('🔍 Task structure analysis:');
            console.log('- elements_shown:', task.elements_shown);
            console.log('- elements_shown_content:', task.elements_shown_content);
            
            if (task.elements_shown_content) {
                const activeElements = Object.entries(task.elements_shown_content)
                    .filter(([name, data]) => data && data !== 'none' && data !== '' && typeof data === 'object' && data.url);
                
                console.log('- Active elements count:', activeElements.length);
                activeElements.forEach(([name, data]) => {
                    console.log(`  • ${name}: z-index=${data.z_index}, layer=${data.layer_name}, url=${data.url}`);
                });
                
                // Validate z-index structure
                this.validateZIndexStructure(activeElements);
            }
        }
        
        // Update navigation
        this.updateNavigation();
        
        // Render task
        this.renderTask(task);
        
        // Update progress
        this.updateProgress();
        
        // Save current task to local storage
        this.saveToLocalStorage();
        
        // Preload images for next task in background
        this.preloadNextTaskImages();
    }
    
    renderTask(task) {
        const container = document.getElementById('taskContainer');
        console.log('Rendering task, container:', container);
        
        if (!container) {
            console.error('❌ taskContainer element not found!');
            return;
        }
        
        // Fade out current task
        container.classList.add('fade-out');
        
        setTimeout(() => {
            // Generate task HTML
            const taskHTML = this.generateTaskHTML(task);
            console.log('Generated task HTML:', taskHTML);
            
            container.innerHTML = taskHTML;
            
            // Fade in new task
            container.classList.remove('fade-out');
            container.classList.add('fade-in');
            
                    // Initialize rating system
        console.log('🔍 About to initialize rating system...');
        this.initializeRatingSystem();
        console.log('🔍 Rating system initialization completed');
        
        // Debug: Check for overlapping elements
        this.debugOverlappingElements();
        
        // Debug grid study structure specifically
        if ('{{ study.study_type }}' === 'grid') {
            this.debugGridStudyStructure();
        }
        
        // Test rating system functionality
        this.testRatingSystem();
            
            // Start task timer
            this.startTaskTimer();
            
            // Debug z-index layering for layer studies
            if ('{{ study.study_type }}' === 'layer') {
                this.debugZIndexLayering();
            }
        }, 200);
    }
    
    generateTaskHTML(task) {
        const studyType = '{{ study.study_type }}';
        let imageHTML = '';
        
        console.log('🔍 Generating task HTML for study type:', studyType);
        console.log('🔍 Task data:', task);
        
        if (studyType === 'grid') {
            // Grid study elements - show ALL active elements
            if (task.elements_shown) {
                imageHTML = '<div class="grid-elements-container">';
                let activeElementsCount = 0;
                
                console.log('🔍 Grid study elements_shown:', task.elements_shown);
                
                for (const [elementName, elementData] of Object.entries(task.elements_shown)) {
                    if (elementName.endsWith('_content') && elementData && elementData !== '') {
                        const baseName = elementName.replace('_content', '');
                        const elementActive = task.elements_shown[baseName];
                        console.log(`🔍 Element ${baseName}: active=${elementActive}, content=${elementData}`);
                        if (elementActive === 1) {
                            activeElementsCount++;
                            imageHTML += `
                                <div class="grid-element-item">
                                    <img src="${elementData}" alt="Element ${baseName}" class="task-image grid-image">
                                    <div class="element-label">${baseName}</div>
                                </div>
                            `;
                        }
                    }
                }
                
                // If no active elements found, show a message
                if (activeElementsCount === 0) {
                    imageHTML = '<div class="no-elements-message">No elements to display</div>';
                } else {
                    imageHTML += '</div>';
                }
                
                console.log(`🔍 Grid study: Found ${activeElementsCount} active elements`);
            } else {
                console.warn('⚠️ No elements_shown found in task data');
            }
        } else if (studyType === 'layer') {
            // Layer study elements - show ALL images with proper z-index layering
            if (task.elements_shown_content) {
                imageHTML = '<div class="vignette-preview" style="border: none !important; box-shadow: none !important; background: none !important;">';
                
                // Debug the raw data structure first
                console.log('🔍 RAW TASK DATA ANALYSIS:');
                console.log('Task object keys:', Object.keys(task));
                console.log('elements_shown_content type:', typeof task.elements_shown_content);
                console.log('elements_shown_content:', task.elements_shown_content);
                
                // Extract and analyze each element
                const allElements = Object.entries(task.elements_shown_content);
                console.log('All elements entries:', allElements);
                
                allElements.forEach(([name, data], index) => {
                    console.log(`Element ${index + 1}:`, {
                        name: name,
                        data: data,
                        type: typeof data,
                        isObject: typeof data === 'object',
                        hasUrl: data && typeof data === 'object' && data.url,
                        zIndex: data && typeof data === 'object' ? data.z_index : 'N/A',
                        layerName: data && typeof data === 'object' ? data.layer_name : 'N/A'
                    });
                });
                
                // Filter valid elements
                const validElements = allElements.filter(([name, data]) => {
                    const isValid = data && data !== 'none' && data !== '' && typeof data === 'object' && data.url;
                    console.log(`Element ${name} valid: ${isValid}`, data);
                    return isValid;
                });
                
                console.log('Valid elements count:', validElements.length);
                
                // Sort elements by z-index to ensure proper layering
                const sortedElements = validElements.sort((a, b) => {
                    // Use actual z-index values from database
                    const zIndexA = a[1].z_index;
                    const zIndexB = b[1].z_index;
                    
                    console.log(`Comparing z-index: ${zIndexA} vs ${zIndexB}`);
                    
                    // Handle undefined z-index values
                    if (zIndexA === undefined && zIndexB === undefined) return 0;
                    if (zIndexA === undefined) return 1; // Put undefined at end
                    if (zIndexB === undefined) return -1; // Put undefined at end
                    
                    return zIndexA - zIndexB; // Sort by z-index ascending
                });
                
                console.log('Final sorted elements:', sortedElements);
                
                sortedElements.forEach(([elementName, elementData], index) => {
                    // Use actual z-index value from database, don't default
                    let zIndex = elementData.z_index;
                    console.log(`Processing element ${index + 1}: ${elementName}, z-index: ${zIndex}, layer: ${elementData.layer_name}`);
                    
                    // Validate z-index
                    if (zIndex === undefined || zIndex === null) {
                        console.warn(`⚠️  Element ${elementName} has no z-index!`);
                        // Fallback: use index as z-index for proper layering
                        zIndex = index;
                        console.log(`🔄 Using fallback z-index: ${zIndex} for ${elementName}`);
                    }
                    
                    imageHTML += `
                        <div class="layer-image" style="z-index: ${zIndex};">
                            <img src="${elementData.url}" 
                                 alt="${elementData.alt_text || elementData.name}" 
                                 class="vignette-layer-img"
                                 data-layer="${elementData.layer_name}"
                                 data-z-index="${zIndex}"
                                 title="${elementName}: ${elementData.layer_name} (z-index: ${zIndex})">
                        </div>
                    `;
                });
                
                imageHTML += '</div>';
            }
        }
        
        return `
           
                <div class="progress-indicator">
                    <div class="task-rectangles">
                        ${this.generateTaskRectangles()}
                    </div>
                   
                </div>
                
                <div class="question-text">
                    {{ study.main_question }}{% if not study.main_question.endswith('?') %}?{% endif %}
                </div>
                

                    ${imageHTML}
     
                <div class="rating-section" style="border: none !important; box-shadow: none !important; background: none !important;">
                    <div class="rating-instructions">
                        <p><strong>{{ study.rating_scale.min_value }} = {{ study.rating_scale.min_label }}</strong></p>
                        {% if study.rating_scale.middle_label %}
                            <p><strong>{{ (study.rating_scale.min_value + study.rating_scale.max_value) // 2 }} = {{ study.rating_scale.middle_label }}</strong></p>
                        {% endif %}
                        <p><strong>{{ study.rating_scale.max_value }} = {{ study.rating_scale.max_label }}</strong></p>
                    </div>
                    
                    <div class="rating-grid">
                        {% for rating in range(study.rating_scale.min_value, study.rating_scale.max_value + 1) %}
                            <div class="rating-option" data-rating="{{ rating }}">
                                <div class="rating-label">
                                    <span class="rating-number">{{ rating }}</span>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            
        `;
    }
    
    initializeRatingSystem() {
        console.log('🔍 Initializing rating system...');
        
        // Simple, direct approach - no cloning, no complex logic
        const ratingOptions = document.querySelectorAll('.rating-option');
        console.log('🔍 Found rating options:', ratingOptions.length);
        
        if (ratingOptions.length === 0) {
            console.error('❌ No rating options found! Check if rating-section HTML is generated correctly.');
            return;
        }
        
        let selectedRating = null;
        
        // Clear any existing selections
        ratingOptions.forEach(option => {
            const label = option.querySelector('.rating-label');
            if (label) {
                label.classList.remove('active', 'hover');
            }
        });
        
        // DEBUG: Check for overlapping elements specifically for grid studies
        if ('{{ study.study_type }}' === 'grid') {
            console.log('🔍 GRID STUDY DEBUG: Checking for overlapping elements...');
            ratingOptions.forEach((option, index) => {
                const rect = option.getBoundingClientRect();
                const rating = option.dataset.rating;
                console.log(`Rating ${rating}: position=(${rect.left}, ${rect.top}), size=${rect.width}x${rect.height}, z-index=${window.getComputedStyle(option).zIndex}`);
                
                // Check if any other elements are overlapping this rating option
                const overlappingElements = document.elementsFromPoint(rect.left + rect.width/2, rect.top + rect.height/2);
                console.log(`Rating ${rating} overlapping elements:`, overlappingElements.map(el => el.className || el.tagName));
                
                // Force rating option to be on top
                option.style.zIndex = '999';
                option.style.pointerEvents = 'auto';
                option.style.position = 'relative';
                
                // Remove any interfering elements
                overlappingElements.forEach(el => {
                    if (el !== option && !el.classList.contains('rating-option') && !el.classList.contains('rating-label')) {
                        console.log(`⚠️ Found interfering element:`, el.className || el.tagName);
                        el.style.pointerEvents = 'none';
                    }
                });
            });
        }
        
        // Simple event listener setup - exactly like working layer study
        ratingOptions.forEach((option, index) => {
            const rating = option.dataset.rating;
            const label = option.querySelector('.rating-label');
            
            console.log(`🔍 Setting up rating option ${index + 1}: rating=${rating}`);
            
            // Direct click event - simple and reliable
            option.onclick = (event) => {
                console.log('🎯 CLICK EVENT TRIGGERED on rating option:', rating);
                console.log('🎯 Event target:', event.target);
                console.log('🎯 Event currentTarget:', event.currentTarget);
                
                if (this.isSubmitting) {
                    console.log('⚠️ Submission in progress, ignoring click');
                    return;
                }
                
                console.log('🎯 Rating selected:', rating, 'for task', this.currentTaskIndex + 1);
                selectedRating = parseInt(rating);
                
                // Simple visual feedback
                ratingOptions.forEach(opt => {
                    const optLabel = opt.querySelector('.rating-label');
                    if (optLabel) optLabel.classList.remove('active');
                });
                
                if (label) {
                    label.classList.add('active');
                }
                
                console.log('✅ Visual feedback applied, submitting rating...');
                
                // Submit rating
                this.submitRating(selectedRating);
            };
            
            // Simple hover effects
            if (label) {
                label.onmouseenter = function() {
                    if (!this.classList.contains('active')) {
                        this.classList.add('hover');
                    }
                };
                
                label.onmouseleave = function() {
                    this.classList.remove('hover');
                };
            }
            
            console.log(`✅ Rating option ${index + 1} (${rating}) setup completed`);
        });
        
        console.log('✅ Rating system initialized for', ratingOptions.length, 'options');
        

    }
    
    startTaskTimer() {
        this.taskStartTime = new Date();
        console.log('Task timer started:', this.taskStartTime);
    }
    
    validateZIndexStructure(activeElements) {
        console.log('🔍 Z-Index Structure Validation:');
        
        const zIndexValues = activeElements.map(([name, data]) => data.z_index);
        const uniqueZIndexes = [...new Set(zIndexValues)];
        
        console.log('- All z-index values:', zIndexValues);
        console.log('- Unique z-index values:', uniqueZIndexes.sort((a, b) => a - b));
        
        // Check for missing z-index values
        const missingZIndex = zIndexValues.some(z => z === undefined || z === null);
        if (missingZIndex) {
            console.warn('⚠️  Some elements are missing z-index values!');
        }
        
        // Check for duplicate z-index values
        const duplicateZIndex = uniqueZIndexes.length !== zIndexValues.length;
        if (duplicateZIndex) {
            console.warn('⚠️  Duplicate z-index values detected!');
        }
        
        // Analyze layer names and suggest proper z-index
        console.log('🔍 Layer Name Analysis:');
        activeElements.forEach(([name, data]) => {
            const layerName = data.layer_name;
            const zIndex = data.z_index;
            
            // Suggest proper z-index based on layer name
            let suggestedZIndex = 'Unknown';
            if (layerName.toLowerCase().includes('background')) suggestedZIndex = 0;
            else if (layerName.toLowerCase().includes('middle')) suggestedZIndex = 1;
            else if (layerName.toLowerCase().includes('foreground')) suggestedZIndex = 2;
            else if (layerName.toLowerCase().includes('top')) suggestedZIndex = 3;
            else if (layerName.toLowerCase().includes('front')) suggestedZIndex = 3;
            
            console.log(`  • ${name}: layer="${layerName}", current z-index=${zIndex}, suggested=${suggestedZIndex}`);
        });
        
        console.log(`- Z-index validation: ${missingZIndex ? '❌' : '✅'} Missing values, ${duplicateZIndex ? '❌' : '✅'} Duplicates`);
    }
    
    debugZIndexLayering() {
        console.log('Layer study detected, checking z-index layering...');
        
        const layerImages = document.querySelectorAll('.layer-image');
        console.log('Found layer images:', layerImages.length);
        
        if (layerImages.length === 0) {
            console.warn('⚠️  No layer images found! Check if elements_shown_content has data.');
            return;
        }
        
        layerImages.forEach((layer, index) => {
            const img = layer.querySelector('img');
            const zIndex = layer.style.zIndex;
            const layerName = img.dataset.layer;
            const zIndexData = img.dataset.zIndex;
            
            console.log(`Layer ${index + 1}:`, {
                element: layer,
                zIndex: zIndex,
                layerName: layerName,
                dataZIndex: zIndexData,
                imgSrc: img.src,
                computedZIndex: window.getComputedStyle(layer).zIndex
            });
            
            // Ensure z-index is properly set
            if (zIndex && zIndex !== 'auto') {
                layer.style.zIndex = zIndex;
                console.log(`✅ Set z-index for layer ${index + 1} to: ${zIndex}`);
            } else {
                console.warn(`⚠️  Layer ${index + 1} has no z-index set: ${zIndex}`);
            }
        });
        
        // Log the stacking order
        console.log('📋 Final stacking order (lowest to highest z-index):');
        const sortedLayers = Array.from(layerImages).sort((a, b) => {
            const zA = parseInt(a.style.zIndex) || 0;
            const zB = parseInt(b.style.zIndex) || 0;
            return zA - zB;
        });
        
        sortedLayers.forEach((layer, index) => {
            const img = layer.querySelector('img');
            const zIndex = layer.style.zIndex;
            const layerName = img.dataset.layer;
            console.log(`  ${index + 1}. ${layerName} (z-index: ${zIndex})`);
        });
    }
    
    async submitRating(rating) {
        if (this.isSubmitting) return;
        
        this.isSubmitting = true;
        const taskEndTime = new Date();
        const taskDuration = (taskEndTime - this.taskStartTime) / 1000;
        
        console.log('Submitting rating:', rating, 'Duration:', taskDuration);
        
        // Create task data with comprehensive information
        const currentTask = this.allTasks[this.currentTaskIndex];
        console.log('📋 Current task data for submission:', currentTask);
        
        const taskData = {
            task_number: this.currentTaskIndex + 1,
            rating: rating,
            timestamp: taskEndTime.toISOString(),
            task_start_time: this.taskStartTime.toISOString(),
            task_end_time: taskEndTime.toISOString(),
            task_duration_seconds: taskDuration,
            task_data: {
                // Grid study data
                elements_shown: currentTask.elements_shown || {},
                // Layer study data
                elements_shown_content: currentTask.elements_shown_content || {},
                // Task metadata
                task_type: currentTask.task_type || '{{ study.study_type }}',
                task_index: this.currentTaskIndex,
                // Element interactions (if available)
                element_interactions: currentTask.element_interactions || [],
                // Additional task context
                task_context: {
                    study_type: '{{ study.study_type }}',
                    total_elements: currentTask.total_elements || 0,
                    active_elements: currentTask.active_elements || 0
                }
            }
        };
        
        console.log('📤 Submitting comprehensive task data:', taskData);
        
        // Store in local storage
        this.taskRatings[this.currentTaskIndex] = taskData;
        this.saveToLocalStorage();
        
        // Check if this is the last task
        if (this.currentTaskIndex === this.totalTasks - 1) {
            console.log('🎯 Last task completed - starting completion process...');
            // Show completion loader for last task
            this.showCompletionLoader();
            // Start the completion process
            this.completeStudy();
        } else {
            // INSTANT progression to next task - no delay!
            console.log('⚡ Instantly advancing to next task...');
            this.advanceToNextTask();
        }
    }
    
    showRatingFeedback() {
        const feedback = document.getElementById('ratingFeedback');
        feedback.classList.add('show');
        
        setTimeout(() => {
            feedback.classList.remove('show');
        }, 800);
    }
    
    showCompletionLoader() {
        console.log('🔄 Showing completion loader for last task...');
        const loader = document.getElementById('completionLoader');
        loader.classList.add('show');
    }
    
    hideCompletionLoader() {
        console.log('✅ Hiding completion loader...');
        const loader = document.getElementById('completionLoader');
        loader.classList.remove('show');
    }
    
    advanceToNextTask() {
        console.log(`🔄 Advancing from task ${this.currentTaskIndex + 1} to next task...`);
        
        if (this.currentTaskIndex < this.totalTasks - 1) {
            // Reset submission flag before showing next task
            this.isSubmitting = false;
            console.log(`✅ Moving to task ${this.currentTaskIndex + 2}`);
            this.showTask(this.currentTaskIndex + 1);
        } else {
            // All tasks completed
            console.log('🎉 All tasks completed!');
            this.completeStudy();
        }
    }
    
    updateNavigation() {
        // Navigation is now handled by the progress bar
        // No need to update individual buttons
        console.log(`Navigation updated - Current task: ${this.currentTaskIndex + 1}`);
    }
    
    generateTaskRectangles() {
        let rectanglesHTML = '';
        for (let i = 0; i < this.totalTasks; i++) {
            let className = 'task-rectangle';
            if (i < this.currentTaskIndex) {
                className += ' completed';
            } else if (i === this.currentTaskIndex) {
                className += ' current';
            } else {
                className += ' upcoming';
            }
            rectanglesHTML += `<div class="${className}" data-task="${i + 1}"></div>`;
        }
        return rectanglesHTML;
    }
    
    calculateProgressPercentage() {
        return ((this.currentTaskIndex + 1) / this.totalTasks) * 100;
    }
    
    updateProgress() {
        const progress = this.calculateProgressPercentage();
        
        console.log(`🔄 Updating progress: ${progress}% - Task ${this.currentTaskIndex + 1} of ${this.totalTasks}`);
        
        // Update task rectangles to show current progress
        const progressIndicator = document.querySelector('.progress-indicator');
        if (progressIndicator) {
            const taskRectangles = progressIndicator.querySelector('.task-rectangles');
            if (taskRectangles) {
                // Regenerate rectangles with updated state
                taskRectangles.innerHTML = this.generateTaskRectangles();
                console.log(`🎯 Task rectangles updated - Current task: ${this.currentTaskIndex + 1}`);
            } else {
                console.warn('⚠️  Task rectangles container not found');
            }
        } else {
            console.warn('⚠️  Progress indicator element not found');
        }
    }
    
    saveToLocalStorage() {
        const data = {
            studyId: this.studyId,
            currentTaskIndex: this.currentTaskIndex,
            taskRatings: this.taskRatings,
            progressPercentage: this.calculateProgressPercentage(), // Save progress percentage
            timestamp: new Date().toISOString()
        };
        
        localStorage.setItem(`study_${this.studyId}_progress`, JSON.stringify(data));
        console.log('💾 Progress saved to local storage:', data);
    }
    
    loadFromLocalStorage() {
        const saved = localStorage.getItem(`study_${this.studyId}_progress`);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.studyId === this.studyId) {
                    this.currentTaskIndex = data.currentTaskIndex || 0;
                    this.taskRatings = data.taskRatings || [];
                    console.log('💾 Progress loaded from local storage:', data);
                    
                    // Restore progress bar state if available
                    if (data.progressPercentage !== undefined) {
                        console.log(`🎯 Restoring progress bar to ${data.progressPercentage}%`);
                        this.restoreProgressBarState(data.progressPercentage);
                    }
                }
            } catch (e) {
                console.log('Could not load saved progress:', e);
            }
        }
    }
    
    restoreProgressBarState(percentage) {
        console.log(`🎯 Restoring progress bar to ${percentage}%`);
        
        // Calculate which task this percentage represents
        const taskIndex = Math.ceil((percentage / 100) * this.totalTasks) - 1;
        this.currentTaskIndex = Math.max(0, Math.min(taskIndex, this.totalTasks - 1));
        
        console.log(`🎯 Restored to task ${this.currentTaskIndex + 1} (${percentage}%)`);
        
        // Update the progress display
        this.updateProgress();
    }
    
    async completeStudy() {
        console.log('🎉 All tasks completed! Starting completion process...');
        
        // Add timeout protection to prevent infinite loading
        const completionTimeout = setTimeout(() => {
            console.warn('⚠️  Completion process taking too long, forcing redirect...');
            this.hideCompletionLoader();
            window.location.href = `/study/${this.studyId}/completed`;
        }, 15000); // 15 second timeout
        
        try {
            // Update loader text to show completion progress
            const loaderText = document.querySelector('#completionLoader .loader-text');
            const loaderSubtext = document.querySelector('#completionLoader .loader-subtext');
            
            if (loaderText && loaderSubtext) {
                loaderText.textContent = 'Task Complete!';
                loaderSubtext.textContent = 'Thank you for completing all tasks. Saving your responses...';
            }
            
            // Submit all ratings to server
            console.log('📤 Submitting all task ratings to server...');
            console.log('📊 Task ratings to submit:', this.taskRatings);
            
            const response = await fetch(`/study/${this.studyId}/submit-all-ratings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                },
                body: JSON.stringify({
                    task_ratings: this.taskRatings
                })
            });
            
            console.log('📡 Server response status:', response.status);
            
            if (response.ok) {
                console.log('✅ All ratings submitted successfully!');
                
                // Clear timeout since we're successful
                clearTimeout(completionTimeout);
                
                // Update loader text for final step
                if (loaderText && loaderSubtext) {
                    loaderText.textContent = 'Responses Saved!';
                    loaderSubtext.textContent = 'Redirecting you to the completion page...';
                }
                
                // Clear local storage
                localStorage.removeItem(`study_${this.studyId}_progress`);
                
                // Redirect to completion page after showing success message
                setTimeout(() => {
                    console.log('🚀 Redirecting to completion page...');
                    window.location.href = `/study/${this.studyId}/completed`;
                }, 2000);
                
            } else {
                const errorText = await response.text();
                console.error('❌ Server error response:', errorText);
                throw new Error(`Server error: ${response.status} - ${errorText}`);
            }
        } catch (error) {
            console.error('❌ Error submitting ratings:', error);
            
            // Clear timeout
            clearTimeout(completionTimeout);
            
            // Hide loader and show error
            this.hideCompletionLoader();
            alert('Error submitting ratings. Please try again or contact support.');
        }
    }
    
    debugOverlappingElements() {
        console.log('🔍 Checking for overlapping elements that might block clicks...');
        
        const ratingOptions = document.querySelectorAll('.rating-option');
        const ratingSection = document.querySelector('.rating-section');
        
        if (ratingSection) {
            const rect = ratingSection.getBoundingClientRect();
            console.log('🔍 Rating section position:', {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                zIndex: window.getComputedStyle(ratingSection).zIndex
            });
        }
        
        ratingOptions.forEach((option, index) => {
            const rect = option.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(option);
            
            console.log(`🔍 Rating option ${index + 1} (${option.dataset.rating}):`, {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                zIndex: computedStyle.zIndex,
                pointerEvents: computedStyle.pointerEvents,
                position: computedStyle.position,
                display: computedStyle.display,
                visibility: computedStyle.visibility
            });
            
            // Check if there are any elements overlapping this rating option
            const elementsAtPoint = document.elementsFromPoint(
                rect.left + rect.width / 2,
                rect.top + rect.height / 2
            );
            
            console.log(`🔍 Elements at rating option ${index + 1} center:`, elementsAtPoint.map(el => ({
                tagName: el.tagName,
                className: el.className,
                id: el.id,
                zIndex: window.getComputedStyle(el).zIndex
            })));
        });
    }
    
    debugGridStudyStructure() {
        console.log('🔍 GRID STUDY STRUCTURE DEBUG:');
        
        // Check grid elements container
        const gridContainer = document.querySelector('.grid-elements-container');
        if (gridContainer) {
            const rect = gridContainer.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(gridContainer);
            
            console.log('🔍 Grid container:', {
                exists: true,
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                display: computedStyle.display,
                position: computedStyle.position,
                zIndex: computedStyle.zIndex,
                overflow: computedStyle.overflow
            });
        } else {
            console.log('❌ Grid container not found!');
        }
        
        // Check grid element items
        const gridItems = document.querySelectorAll('.grid-element-item');
        console.log(`🔍 Grid items found: ${gridItems.length}`);
        
        gridItems.forEach((item, index) => {
            const rect = item.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(item);
            
            console.log(`🔍 Grid item ${index + 1}:`, {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                display: computedStyle.display,
                position: computedStyle.position,
                zIndex: computedStyle.zIndex
            });
        });
        
        // Check if grid elements are interfering with rating system
        const ratingSection = document.querySelector('.rating-section');
        if (ratingSection && gridContainer) {
            const ratingRect = ratingSection.getBoundingClientRect();
            const gridRect = gridContainer.getBoundingClientRect();
            
            console.log('🔍 Layout analysis:', {
                ratingSectionTop: ratingRect.top,
                ratingSectionBottom: ratingRect.bottom,
                gridContainerTop: gridRect.top,
                gridContainerBottom: gridRect.bottom,
                overlap: !(ratingRect.bottom < gridRect.top || ratingRect.top > gridRect.bottom)
            });
        }
    }
    
    testRatingSystem() {
        console.log('🧪 Testing rating system functionality...');
        
        // Check if rating options exist
        const ratingOptions = document.querySelectorAll('.rating-option');
        console.log('🧪 Rating options found:', ratingOptions.length);
        
        if (ratingOptions.length === 0) {
            console.error('🧪 ❌ No rating options found for testing!');
            return;
        }
        
        // Test each rating option
        ratingOptions.forEach((option, index) => {
            const rating = option.dataset.rating;
            const label = option.querySelector('.rating-label');
            
            console.log(`🧪 Rating option ${index + 1} (${rating}):`, {
                exists: !!option,
                hasDataset: !!option.dataset.rating,
                hasLabel: !!label,
                labelText: label ? label.textContent : 'N/A',
                isClickable: option.style.pointerEvents !== 'none',
                zIndex: window.getComputedStyle(option).zIndex,
                position: window.getComputedStyle(option).position
            });
            
            // Test if element is actually clickable
            const rect = option.getBoundingClientRect();
            console.log(`🧪 Rating option ${index + 1} position:`, {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                visible: rect.width > 0 && rect.height > 0
            });
        });
        
        // Test if any elements are overlapping the rating options
        const ratingSection = document.querySelector('.rating-section');
        if (ratingSection) {
            const ratingRect = ratingSection.getBoundingClientRect();
            console.log('🧪 Rating section bounds:', {
                top: ratingRect.top,
                left: ratingRect.left,
                width: ratingRect.width,
                height: ratingRect.height
            });
            
            // Check for overlapping elements
            const centerX = ratingRect.left + ratingRect.width / 2;
            const centerY = ratingRect.top + ratingRect.height / 2;
            const elementsAtCenter = document.elementsFromPoint(centerX, centerY);
            
            console.log('🧪 Elements at rating section center:', elementsAtCenter.map(el => ({
                tagName: el.tagName,
                className: el.className,
                id: el.id
            })));
        }
        
        console.log('🧪 Rating system test completed');
    }
}

// Initialize lightning-fast task flow when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 DOM Content Loaded - Starting initialization...');
    
    // Calculate and apply proper screen dimensions
    function calculateScreenDimensions() {
        const vh = window.innerHeight * 0.01;
        const vw = window.innerWidth * 0.01;
        
        console.log('📱 Screen dimensions:', {
            innerHeight: window.innerHeight,
            innerWidth: window.innerWidth,
            vh: vh,
            vw: vw
        });
        
        // Set CSS custom properties for dynamic sizing
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        document.documentElement.style.setProperty('--vw', `${vw}px`);
        
        // Apply calculated heights to prevent scrolling
        const body = document.body;
        const html = document.documentElement;
        const mainContent = document.getElementById('main-content');
        const taskContainer = document.getElementById('taskContainer');
        
        if (body) body.style.height = `${window.innerHeight}px`;
        if (html) html.style.height = `${window.innerHeight}px`;
        if (mainContent) mainContent.style.height = `${window.innerHeight}px`;
        if (taskContainer) taskContainer.style.height = `${window.innerHeight}px`;
        
        console.log('✅ Screen dimensions applied');
    }
    
    // Calculate dimensions on load and resize
    calculateScreenDimensions();
    window.addEventListener('resize', calculateScreenDimensions);
    window.addEventListener('orientationchange', () => {
        setTimeout(calculateScreenDimensions, 100);
    });
    
    // Check if required elements exist
    const taskContainer = document.getElementById('taskContainer');
    
    if (!taskContainer) {
        console.error('❌ CRITICAL: taskContainer element not found!');
        return;
    }
    
    const studyId = '{{ study._id }}';
    const totalTasks = {{ total_tasks }};
    const allTasks = {{ all_tasks|tojson|safe }};
    
    console.log('🚀 Initializing Lightning Task Flow...');
    console.log('Study ID:', studyId);
    console.log('Total Tasks:', totalTasks);
    console.log('All Tasks:', allTasks);
    
    // Create and start the lightning-fast task flow
    try {
        window.taskFlow = new LightningTaskFlow(studyId, totalTasks, allTasks);
        console.log('✅ LightningTaskFlow initialized successfully!');
        
        // Save progress before page unload (refresh, close, etc.)
        window.addEventListener('beforeunload', () => {
            if (window.taskFlow) {
                console.log('💾 Saving progress before page unload...');
                window.taskFlow.saveToLocalStorage();
            }
        });
        
        // Save progress when page becomes hidden (mobile app switching, etc.)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && window.taskFlow) {
                console.log('💾 Saving progress - page hidden...');
                window.taskFlow.saveToLocalStorage();
            }
        });
        
    } catch (error) {
        console.error('❌ Error initializing LightningTaskFlow:', error);
    }
});
</script>
{% endblock %}

