{% extends "base.html" %}
{% block title %}{{ study.title }} - Tasks{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/study_participation.css') }}">
<style>
/* Remove top space and colored bars for tasks page */
body {
    margin: 0 !important;
    padding: 0 !important;
    overflow: hidden !important; /* Prevent scrolling */
    height: 100vh !important; /* Force full viewport height */
    /* Dark brown background */
}

/* Override main content top margin and padding */
#main-content.app-main {
    margin: 0 !important;
    padding: 0 !important;
    background: transparent !important;
    overflow: hidden !important; /* Prevent scrolling */
    height: 100vh !important; /* Force full viewport height */
}

/* Remove any top bars or spacing */
.app-header,
.progress-section,
.flash-container {
    display: none !important;
}

/* Ensure countdown takes full screen */
.image-countdown {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
}

/* Task container should start from top */
.task-container {
    margin-top: 0 !important;
    padding-top: 0 !important;
    overflow: hidden !important; /* Prevent scrolling */
    height: 100vh !important; /* Force full viewport height */
}

/* Global scroll prevention */
* {
    box-sizing: border-box;
}

html, body {
    overflow: hidden !important;
    height: 100vh !important;
    width: 100vw !important;
}

/* Use calculated viewport height for better mobile support */
:root {
    --vh: 1vh;
    --vw: 1vw;
}

/* Force exact screen dimensions */
html, body, #main-content, .task-container {
    height: calc(var(--vh, 1vh) * 100) !important;
    width: calc(var(--vw, 1vw) * 100) !important;
    overflow: hidden !important;
}

/* Progress bar removed - no more top space */
/* Lightning-fast task transitions */
.task-container {
    transition: opacity 0.2s ease-in-out;
}

.task-container.fade-out {
    opacity: 0;
}

.task-container.fade-in {
    opacity: 1;
}

/* Progress bar removed - too big */

/* Modern UI - Card-based layout like 3rd image */
body {
  
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* Main task card */
.task-card {
    background: white;
    border-radius: 2vh;
    padding: 1vh;
    margin: 0 0.5vh 0.5vh 0.5vh;
    box-shadow: 0 0.4vh 2vh rgba(0,0,0,0.15);
    height: calc(calc(var(--vh, 1vh) * 99) - 1vh); /* 99vh minus margins */
    overflow: hidden; /* Prevent content overflow */
    box-sizing: border-box; /* Include padding in height calculation */
}

/* Progress indicator - Instagram stories style with individual rectangles */
.progress-indicator {
    background: transparent; /* No background for the container */
    border-radius: 1vh;
    text-align: center;
    font-weight: 500;
    font-size: 1.4vh;
    position: relative;
    overflow: visible;
    min-width: 20vw;
    display: block;
    height: auto;
    padding: 1.5vh 0 0.5vh 0;
    margin: 1vh auto;
}

/* Task rectangles container */
.task-rectangles {
    display: flex;
    gap: 0.4vh;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    max-width: 100%;
}

/* Individual task rectangle */
.task-rectangle {
    width: 1.2vh;
    height: 0.8vh;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 0.2vh;
    transition: all 0.3s ease-in-out;
    border: 0.1vh solid rgba(255, 255, 255, 0.2);
}

/* Completed task rectangle */
.task-rectangle.completed {
    background: linear-gradient(90deg, #4CAF50, #45a049);
    border-color: #4CAF50;
    transform: scale(1.1);
    box-shadow: 0 0 8px rgba(76, 175, 80, 0.4);
}

/* Current task rectangle */
.task-rectangle.current {
    background: linear-gradient(90deg, #FF9800, #F57C00);
    border-color: #FF9800;
    transform: scale(1.2);
    box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
    animation: pulse 1.5s ease-in-out infinite;
}

/* Upcoming task rectangle */
.task-rectangle.upcoming {
    background: lightgrey;
    border-color: #D3D3D3;
    opacity: 0.8;
}

/* Progress indicator text */
.progress-indicator .progress-text {
    position: absolute;
    top: -20px; /* Position text above the bar */
    right: 0;
    color: #1976D2;
    font-weight: 600;
    font-size: 12px;
    z-index: 2;
}



/* Question text */
.question-text {
    font-size: 2.2vh;
    font-weight: 700;
    color: #333;
    margin-bottom: 0.6vh;
    text-align: center;
}

/* Image container */
.image-container {
    text-align: center;
    margin-bottom: 0.5vh;
    height: calc(calc(var(--vh, 1vh) * 60) - 2vh); /* 60vh minus margins */
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* Prevent image overflow */
}

.task-image {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    border-radius: 15px;
    box-shadow: none !important;
    border: none !important;
    object-fit: contain;
}

/* Grid elements container for grid studies */
.grid-elements-container {
    display: grid;
    gap: 1rem;
    padding: 1rem;
 
    border-radius: 12px;
   
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    /* Ensure grid elements don't interfere with rating options */
    position: relative;
    z-index: 1;
}

/* 2 elements: 2 rows, 1 column (stacked vertically) */
.grid-elements-container.elements-2 {
    grid-template-columns: 1fr;
    grid-template-rows: 1fr 1fr;
}

/* 3 elements: 2 rows - first row 2 columns, second row 1 centered column */
.grid-elements-container.elements-3 {
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
}

.grid-elements-container.elements-3 .grid-element-item:nth-child(3) {
    grid-column: 1 / -1;
    justify-self: center;
    max-width: 50%;
}

/* 4 elements: 2 rows, 2 columns */
.grid-elements-container.elements-4 {
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
}

/* Fallback for other numbers of elements */
.grid-elements-container:not(.elements-2):not(.elements-3):not(.elements-4) {
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    grid-auto-rows: 1fr;
}

.grid-element-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;

    min-height: 200px;
    justify-content: center;
}

.grid-image {
    width: 100%;
    max-width: 180px;
    height: auto;
    margin-bottom: 0.5rem;
    border-radius: 8px;
}

.element-label {
    font-size: 0.875rem;
    font-weight: 500;
    color: #475569;
    background: #f1f5f9;
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    border: 1px solid #e2e8f0;
}

.no-elements-message {
    text-align: center;
    padding: 2rem;
    color: #64748b;
    font-style: italic;
    background: #f1f5f9;
    border-radius: 8px;
    border: 1px dashed #cbd5e1;
}

/* Vignette preview for layer studies */
.vignette-preview {
    border: none !important;
    box-shadow: none !important;
    background: none !important;
    position: relative;
    width: 100%;
    height: calc(calc(var(--vh, 1vh) * 65) - 1vh); /* 55vh minus margins */
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden; /* Prevent overflow */
}

.layer-image {
    border: none !important;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 100%;
    max-height: 100%;
}

.vignette-layer-img {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    border-radius: 15px;
    box-shadow: none !important;
    border: none !important;
    object-fit: contain;
}

/* Rating section */
.rating-section {
    background: white;
    border-radius: 1.5vh;
    padding: 2vh 1.5vh 1.5vh 1.5vh; /* More top padding to prevent cut-off */
    box-shadow: 0 0.2vh 1vh rgba(0,0,0,0.05);
    margin-top: 1vh; /* Add top margin for breathing room */
    overflow: visible; /* Allow rating circles to be fully visible */
    min-height: 15vh; /* Ensure minimum height for rating section */
    /* Ensure rating section is above content but below loader */
    position: relative !important;
    z-index: 50 !important;
}

.rating-instructions {
    display: flex;
    gap: 1vh;
    flex-direction: row;
    justify-items: center;
    justify-content: center;
    text-align: center;
    margin-bottom: 1.5vh; /* Add bottom margin for spacing */
    color: #666;
    font-size: 1.3vh;
}

.rating-instructions p {
    
    font-weight: 500;
}

.rating-grid {
    margin: 0 !important;
    padding: 1vh 0 !important; /* Add vertical padding to prevent cut-off */
    display: flex;
    justify-content: center;
    gap: 1.2vh;
    flex-wrap: wrap;
    align-items: center; /* Ensure proper vertical alignment */
}

.rating-option {
    cursor: pointer !important;
    transition: all 0.2s ease;
    position: relative !important;
    z-index: 50 !important; /* Balanced z-index - above content but below loader */
    pointer-events: auto !important;
    user-select: none;
    /* Ensure the rating option is clickable */
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    background: transparent !important;
    /* Force rating options to be clickable */
    position: relative !important;
    z-index: 999 !important; /* Higher z-index for grid studies */
}

/* Specific fix for grid studies */
.grid-elements-container + .rating-section .rating-option {
    z-index: 999 !important;
    pointer-events: auto !important;
    position: relative !important;
}

/* Ensure grid elements don't interfere with ratings */
.grid-elements-container {
    pointer-events: none !important;
}

.grid-elements-container img {
    pointer-events: none !important;
}

.grid-elements-container .element-label {
    pointer-events: none !important;
}

.rating-label {
    width: 5vh;
    height: 5vh;
    border: 0.2vh solid #E0E0E0;
    border-radius: 2.5vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    font-weight: 600;
    font-size: 1.6vh;
    color: #333;
    transition: all 0.2s ease;
}

.rating-label:hover {
    border-color: #E0E0E0;
    background: #F5F5F5;
    transform: scale(1.05);
}

.rating-label.active {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
    transform: scale(1.1);
    z-index: 10; /* Ensure active rating is on top */
    position: relative; /* Create stacking context */
}

/* Task navigation removed - only top progress bar remains */

/* Rating submission feedback */
.rating-feedback {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #4CAF50;
    color: white;
    padding: 20px 40px;
    border-radius: 15px;
    font-size: 18px;
    font-weight: bold;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.3s ease;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}

.rating-feedback.show {
    opacity: 1;
}

/* Image Loading Countdown */
.image-countdown {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    font-family: 'Arial', sans-serif;
    margin: 0 !important;
    padding: 0 !important;
}

.countdown-content {
    text-align: center;
    color: white;
}

.countdown-number {
    font-size: 12vh;
    font-weight: bold;
    margin-bottom: 2vh;
    text-shadow: 0 0 2vh rgba(255, 255, 255, 0.5);
    animation: pulse 1s ease-in-out infinite;
}

.countdown-text {
    font-size: 3.6vh;
    font-weight: bold;
    margin-bottom: 1.5vh;
    text-transform: uppercase;
    letter-spacing: 0.2vh;
    text-shadow: 0 0 1.5vh rgba(255, 255, 255, 0.3);
}

.countdown-subtext {
    font-size: 1.8vh;
    opacity: 0.9;
    text-shadow: 0 0 1vh rgba(255, 255, 255, 0.2);
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Study completion loader */
.completion-loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 3000;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
}

.completion-loader.show {
    opacity: 1;
    visibility: visible;
}

.loader-spinner {
    width: 60px;
    height: 60px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #4CAF50;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loader-text {
    color: white;
    font-size: 18px;
    font-weight: 500;
    text-align: center;
    margin-bottom: 10px;
}

.loader-subtext {
    color: #ccc;
    font-size: 14px;
    text-align: center;
    max-width: 300px;
    line-height: 1.4;
}

/* Loading states */
.loading {
    opacity: 0.7;
    pointer-events: none;
}

/* Responsive design */
@media (max-width: 480px) {
    .task-card {
        margin: 0 10px 10px 10px;
        padding: 15px;
        min-height: 90vh;
    }
    
    .question-text {
        font-size: 16px;
    }
    
    .image-container {
        height: 65vh;
    }
    
    .rating-section {
        padding: 12px;
    }
    
    /* Mobile progress indicator adjustments */
.progress-indicator {
    margin: 0 !important;
    min-width: 15vw;
    padding: 1vh 0 0.3vh 0;
}

.task-rectangles {
    gap: 0.3vh;
}

.task-rectangle.upcoming {
    background: lightgrey;
    border-color: #D3D3D3;
}

.task-rectangle {
    width: 1vh;
    height: 0.6vh;
}

.progress-text {
    font-size: 1.1vh;
    top: -1.8vh;
}
}
</style>
{% endblock %}

{% block content %}
<!-- Progress bar removed - too big -->

<!-- Task container -->
<div class="task-container" id="taskContainer">
    <!-- Tasks will be dynamically loaded here -->
</div>

<!-- Rating feedback -->
<div class="rating-feedback" id="ratingFeedback">
    ✓ Task Completed!
</div>

    <!-- Image Loading Countdown -->
    <div id="imageCountdown" class="image-countdown">
        <div class="countdown-content">
            <div class="countdown-number" id="countdownNumber">3</div>
            <div class="countdown-text" id="countdownText">GET READY!</div>
            <div class="countdown-subtext" id="countdownSubtext">Loading your first task...</div>
        </div>
    </div>

<!-- Study completion loader -->
<div class="completion-loader" id="completionLoader">
    <div class="loader-spinner"></div>
    <div class="loader-text">Completing Your Study...</div>
    <div class="loader-subtext">Please wait while we save your responses and prepare your completion page.</div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/image-preloader.js') }}"></script>
<script>
// Lightning-fast task flow - all tasks loaded upfront with image preloading
class LightningTaskFlow {
    constructor(studyId, totalTasks, allTasks) {
        this.studyId = studyId;
        this.totalTasks = totalTasks;
        this.allTasks = allTasks;
        this.currentTaskIndex = 0;
        this.taskRatings = [];
        this.isSubmitting = false;
        this.countdownTimeouts = [];
        this.preloadedImages = new Map();
        
        // Initialize
        this.userHasInteracted = false;
        this.init();
    }
    
    init() {
        console.log('🚀 Lightning Task Flow initialized!');
        console.log(`Total tasks: ${this.totalTasks}`);
        console.log('All tasks loaded:', this.allTasks);
        console.log('🔍 First task structure:', this.allTasks[0]);
        console.log('🔍 First task elements_shown:', this.allTasks[0]?.elements_shown);
        
        // Debug task data structure for grid studies
        if (this.allTasks && this.allTasks.length > 0) {
            const firstTask = this.allTasks[0];
            console.log('🔍 FIRST TASK DETAILED ANALYSIS:');
            console.log('- Task keys:', Object.keys(firstTask));
            console.log('- Task type:', typeof firstTask);
            console.log('- elements_shown type:', typeof firstTask.elements_shown);
            console.log('- elements_shown:', firstTask.elements_shown);
            
            if (firstTask.elements_shown) {
                console.log('- elements_shown entries:', Object.entries(firstTask.elements_shown));
                console.log('- elements_shown length:', Object.keys(firstTask.elements_shown).length);
                
                // Check for grid study specific structure
                const contentKeys = Object.keys(firstTask.elements_shown).filter(key => key.endsWith('_content'));
                const elementKeys = Object.keys(firstTask.elements_shown).filter(key => !key.endsWith('_content'));
                
                console.log('- Content keys (ending with _content):', contentKeys);
                console.log('- Element keys (not ending with _content):', elementKeys);
                
                contentKeys.forEach(key => {
                    const baseKey = key.replace('_content', '');
                    const content = firstTask.elements_shown[key];
                    const isActive = firstTask.elements_shown[baseKey];
                    console.log(`  • ${key} -> ${baseKey}: content="${content}", active=${isActive}`);
                });
            }
        }
        
        // Always start from task 1 (index 0) for simplicity
        this.currentTaskIndex = 0;
        this.taskRatings = [];
        console.log(`🎯 Starting from task 1 (index: ${this.currentTaskIndex})`);
        
        // Calculate and apply screen dimensions
        this.calculateAndApplyDimensions();
        
        // Check if images are fully loaded before starting countdown
        this.checkImagesAndStartCountdown();
    }
    
    calculateAndApplyDimensions() {
        const vh = window.innerHeight * 0.01;
        const vw = window.innerWidth * 0.01;
        
        console.log('📱 TaskFlow Screen dimensions:', {
            innerHeight: window.innerHeight,
            innerWidth: window.innerWidth,
            vh: vh,
            vw: vw
        });
        
        // Set CSS custom properties
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        document.documentElement.style.setProperty('--vw', `${vw}px`);
        
        // Force recalculation of layout
        this.updateLayoutDimensions();
    }
    
    updateLayoutDimensions() {
        const taskCard = document.querySelector('.task-card');
        if (taskCard) {
            const cardHeight = window.innerHeight - 2; // 2px for margins
            taskCard.style.height = `${cardHeight}px`;
            console.log(`✅ Task card height set to: ${cardHeight}px`);
        }
    }
    
    // Image preloading is now handled by the welcome screen preloader service
    
    showImageCountdown() {
        console.log('🎮 Showing game-style countdown while images load...');
        const countdown = document.getElementById('imageCountdown');
        countdown.style.display = 'flex';
    }
    
    hideImageCountdown() {
        console.log('✅ Hiding countdown, showing first task...');
        const countdown = document.getElementById('imageCountdown');
        countdown.style.display = 'none';
    }
    

    

    

    
    startCountdown() {
        console.log('🎮 Starting countdown: 3... 2... 1... GO!');
        
        // Always check if images are ready first
        const progress = window.imagePreloader.getLoadingProgress();
        console.log('🔍 Countdown check - Image progress:', progress);
        
        if (progress.isComplete) {
            console.log('✅ Images ready, starting countdown immediately');
            this.normalCountdown();
        } else {
            console.log('⏳ Images not ready, showing finalizing screen and waiting');
            this.showFinalizingAndWaitForImages();
        }
    }

    normalCountdown() {
        // Get countdown elements
        const countdownNumber = document.getElementById('countdownNumber');
        const countdownText = document.getElementById('countdownText');
        const countdownSubtext = document.getElementById('countdownSubtext');
        
        if (!countdownNumber || !countdownText || !countdownSubtext) {
            console.error('❌ Countdown elements not found!');
            this.hideImageCountdown();
            this.showTask(this.currentTaskIndex);
            return;
        }
        
        console.log('✅ Countdown elements found, starting...');
        
        // Clear any existing timeouts
        if (this.countdownTimeouts) {
            this.countdownTimeouts.forEach(timeout => clearTimeout(timeout));
        }
        this.countdownTimeouts = [];
        
        // Simple countdown sequence
        let count = 3;
        
        const updateCountdown = () => {
            if (count > 0) {
                countdownNumber.textContent = count;
                countdownText.textContent = 'GET READY!';
                countdownSubtext.textContent = `Starting in ${count}...`;
                console.log(`📱 Countdown: ${count}`);
                count--;
                
                const timeout = setTimeout(updateCountdown, 1000);
                this.countdownTimeouts.push(timeout);
            } else {
                countdownNumber.textContent = 'GO!';
                countdownText.textContent = 'TASK READY!';
                if (this.currentTaskIndex === 0) {
                    countdownSubtext.textContent = 'Your first task is ready!';
                } else {
                    countdownSubtext.textContent = `Continuing with task ${this.currentTaskIndex + 1}!`;
                }
                console.log('📱 Countdown: GO!');
                
                const timeout = setTimeout(() => {
                    console.log(`🎯 Countdown finished, showing task ${this.currentTaskIndex + 1}`);
                    this.hideImageCountdown();
                    this.showTask(this.currentTaskIndex);
                }, 1000);
                this.countdownTimeouts.push(timeout);
            }
        };
        
        // Start the countdown
        updateCountdown();
        console.log('⏰ Countdown started');
    }

    checkImagesAndStartCountdown() {
        console.log('🔍 Checking image loading status before starting countdown...');
        
        // Show countdown screen first
        this.showImageCountdown();
        
        // Check if images are already loaded
        if (window.imagePreloader) {
            const progress = window.imagePreloader.getLoadingProgress();
            console.log(`🔍 Current image progress: ${progress.loaded}/${progress.total} loaded`);
            
            if (progress.isComplete && progress.total > 0) {
                console.log('✅ All images already loaded, starting countdown immediately');
                this.startCountdown();
                return;
            }
            
            if (progress.total === 0) {
                console.log('⚠️ No images to load, starting countdown immediately');
                this.startCountdown();
                return;
            }
        }
        
        // Images not fully loaded, show finalizing screen
        this.showFinalizingAndWaitForImages();
    }

    showFinalizingAndWaitForImages() {
        console.log('🎯 Showing finalizing screen while images load');
        
        const countdownNumber = document.getElementById('countdownNumber');
        const countdownText = document.getElementById('countdownText');
        const countdownSubtext = document.getElementById('countdownSubtext');
        
        if (countdownNumber && countdownText && countdownSubtext) {
            countdownNumber.textContent = '...';
            countdownText.textContent = 'FINALIZING';
            countdownSubtext.textContent = 'Loading images...';
        }
        
        // Continue loading images in background
        if (window.studyData && window.studyData.study_type) {
            window.imagePreloader.continueSilentLoading(window.studyData);
        }
        
        // Check every 500ms for completion
        const checkInterval = setInterval(() => {
            const progress = window.imagePreloader.getLoadingProgress();
            console.log(`🔍 Finalizing check - ${progress.loaded}/${progress.total} loaded`);
            
            if (progress.isComplete) {
                clearInterval(checkInterval);
                console.log('✅ Images loaded, starting countdown');
                this.startCountdown();
            }
        }, 500);
        
        // Safety timeout - start countdown after 30 seconds regardless
        setTimeout(() => {
            clearInterval(checkInterval);
            console.log('⏰ Timeout reached, starting countdown anyway');
            this.startCountdown();
        }, 30000);
    }
    
    // All images are preloaded by the welcome screen preloader service
    
    generateNavigation() {
        // Navigation is now handled by the progress bar
        // No need to generate individual buttons
        console.log('Navigation initialized with progress bar');
    }
    
    showTask(taskIndex) {
        if (taskIndex < 0 || taskIndex >= this.totalTasks) return;
        
        this.currentTaskIndex = taskIndex;
        const task = this.allTasks[taskIndex];
        
        console.log(`🎯 Showing task ${taskIndex + 1} of ${this.totalTasks}:`, task);
        console.log(`🔍 Current task index: ${this.currentTaskIndex}`);
        
        // Reset submission flag when showing a new task
        this.isSubmitting = false;
        
        // Add a flag to track if user has interacted with the page
        this.userHasInteracted = false;
        
        // Debug task structure for layer studies
        if ('{{ study.study_type }}' === 'layer') {
            console.log('🔍 Task structure analysis:');
            console.log('- elements_shown:', task.elements_shown);
            console.log('- elements_shown_content:', task.elements_shown_content);
            
            if (task.elements_shown_content) {
                const activeElements = Object.entries(task.elements_shown_content)
                    .filter(([name, data]) => data && data !== 'none' && data !== '' && typeof data === 'object' && data.url);
                
                console.log('- Active elements count:', activeElements.length);
                activeElements.forEach(([name, data]) => {
                    console.log(`  • ${name}: z-index=${data.z_index}, layer=${data.layer_name}, url=${data.url}`);
                });
                
                // Validate z-index structure
                this.validateZIndexStructure(activeElements);
            }
        }
        
        // Render task
        this.renderTask(task);
        
        // Update progress
        this.updateProgress();
    }
    
    renderTask(task) {
        const container = document.getElementById('taskContainer');
        console.log('Rendering task, container:', container);
        
        if (!container) {
            console.error('❌ taskContainer element not found!');
            return;
        }
        
        // Fade out current task
        container.classList.add('fade-out');
        
        setTimeout(() => {
            // Generate task HTML
            const taskHTML = this.generateTaskHTML(task);
            console.log('Generated task HTML:', taskHTML);
            
            container.innerHTML = taskHTML;
            
            // Fade in new task
            container.classList.remove('fade-out');
            container.classList.add('fade-in');
            
                    // Initialize rating system
        console.log('🔍 About to initialize rating system...');
        this.initializeRatingSystem();
        console.log('🔍 Rating system initialization completed');
        
        // Debug: Check for overlapping elements
        this.debugOverlappingElements();
        
        // Debug grid study structure specifically
        if ('{{ study.study_type }}' === 'grid') {
            this.debugGridStudyStructure();
        }
        
        // Test rating system functionality (disabled to prevent auto-submission)
        // this.testRatingSystem();
            
            // Start task timer
            this.startTaskTimer();
            
            // Debug z-index layering for layer studies
            if ('{{ study.study_type }}' === 'layer') {
                this.debugZIndexLayering();
            }
        }, 200);
    }
    
    generateTaskHTML(task) {
        const studyType = '{{ study.study_type }}';
        let imageHTML = '';
        
        console.log('🔍 Generating task HTML for study type:', studyType);
        console.log('🔍 Task data:', task);
        
        if (studyType === 'grid' || studyType === 'grid_v2') {
            // Grid study elements - show ALL active elements
            if (task.elements_shown_content) {
                let activeElementsCount = 0;
                
                console.log('🔍 Grid study elements_shown_content:', task.elements_shown_content);
                
                // First pass: count active elements
                for (const [elementName, elementContent] of Object.entries(task.elements_shown_content)) {
                    if (elementContent && elementContent !== null) {
                        const elementActive = task.elements_shown[elementName];
                        if (elementActive === 1) {
                            activeElementsCount++;
                        }
                    }
                }
                
                // Create container with appropriate class based on element count
                let containerClass = 'grid-elements-container';
                if (activeElementsCount >= 2 && activeElementsCount <= 4) {
                    containerClass += ` elements-${activeElementsCount}`;
                }
                
                console.log(`🔍 Grid study: Using container class "${containerClass}" for ${activeElementsCount} active elements`);
                
                // If no active elements found, show a message
                if (activeElementsCount === 0) {
                    imageHTML = '<div class="no-elements-message">No elements to display</div>';
                } else {
                    imageHTML = `<div class="${containerClass}">`;
                    
                    // Second pass: build HTML for active elements
                    for (const [elementName, elementContent] of Object.entries(task.elements_shown_content)) {
                        if (elementContent && elementContent !== null) {
                            const elementActive = task.elements_shown[elementName];
                            console.log(`🔍 Element ${elementName}: active=${elementActive}, content=`, elementContent);
                            if (elementActive === 1) {
                                console.log(`✅ Active element ${elementName}:`, elementContent);
                                
                                // Use preloaded image if available, otherwise fallback to URL
                                // For grid studies, URL is in elementContent.content, not elementContent.url
                                const imageUrl = elementContent.content || elementContent.url;
                                const preloadedImg = window.imagePreloader ? window.imagePreloader.getPreloadedImage(imageUrl) : null;
                                const imageSrc = preloadedImg ? preloadedImg.src : imageUrl;
                                
                                imageHTML += `
                                    <div class="grid-element-item">
                                        <img src="${imageSrc}" alt="${elementContent.alt_text || elementContent.name}" class="task-image grid-image">
                                      
                                    </div>
                                `;
                            }
                        }
                    }
                    
                    imageHTML += '</div>';
                }
                
                console.log(`🔍 Grid study: Found ${activeElementsCount} active elements`);
            } else if (task.elements_shown) {
                // Legacy grid study format
                let activeElementsCount = 0;
                
                console.log('🔍 Legacy grid study elements_shown:', task.elements_shown);
                
                // First pass: count active elements
                for (const [elementName, elementData] of Object.entries(task.elements_shown)) {
                    if (elementName.endsWith('_content') && elementData && elementData !== '') {
                        const baseName = elementName.replace('_content', '');
                        const elementActive = task.elements_shown[baseName];
                        if (elementActive === 1) {
                            activeElementsCount++;
                        }
                    }
                }
                
                // Create container with appropriate class based on element count
                let containerClass = 'grid-elements-container';
                if (activeElementsCount >= 2 && activeElementsCount <= 4) {
                    containerClass += ` elements-${activeElementsCount}`;
                }
                
                console.log(`🔍 Legacy grid study: Using container class "${containerClass}" for ${activeElementsCount} active elements`);
                
                // If no active elements found, show a message
                if (activeElementsCount === 0) {
                    imageHTML = '<div class="no-elements-message">No elements to display</div>';
                } else {
                    imageHTML = `<div class="${containerClass}">`;
                    
                    // Second pass: build HTML for active elements
                    for (const [elementName, elementData] of Object.entries(task.elements_shown)) {
                        if (elementName.endsWith('_content') && elementData && elementData !== '') {
                            const baseName = elementName.replace('_content', '');
                            const elementActive = task.elements_shown[baseName];
                            console.log(`🔍 Element ${baseName}: active=${elementActive}, content=${elementData}`);
                            if (elementActive === 1) {
                                console.log(`✅ Active legacy element ${baseName}:`, elementData);
                                // Use preloaded image if available, otherwise fallback to URL
                                const preloadedImg = window.imagePreloader ? window.imagePreloader.getPreloadedImage(elementData) : null;
                                const imageSrc = preloadedImg ? preloadedImg.src : elementData;
                                
                                imageHTML += `
                                    <div class="grid-element-item">
                                        <img src="${imageSrc}" alt="Element ${baseName}" class="task-image grid-image">
                                       
                                    </div>
                                `;
                            }
                        }
                    }
                    
                    imageHTML += '</div>';
                }
                
                console.log(`🔍 Legacy grid study: Found ${activeElementsCount} active elements`);
            } else {
                console.warn('⚠️ No elements_shown_content or elements_shown found in task data');
            }
        } else if (studyType === 'layer') {
            // Layer study elements - show ALL images with proper z-index layering
            if (task.elements_shown_content) {
                imageHTML = '<div class="vignette-preview" style="border: none !important; box-shadow: none !important; background: none !important;">';
                
                // Add default background as layer with z-index 0 if it exists
                if (window.studyData && window.studyData.default_background && window.studyData.default_background.url) {
                    imageHTML += `
                        <div class="layer-image background-layer" style="z-index: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.9;">
                            <img src="${window.studyData.default_background.url}" 
                                 alt="Default Background" 
                                 class="vignette-layer-img background-layer-img"
                                 data-layer="Background"
                                 data-z-index="0"
                                 title="Default Background (z-index: 0)"
                                 onerror="this.style.display='none';">
                        </div>
                    `;
                }
                
                // Debug the raw data structure first
                console.log('🔍 RAW TASK DATA ANALYSIS:');
                console.log('Task object keys:', Object.keys(task));
                console.log('elements_shown_content type:', typeof task.elements_shown_content);
                console.log('elements_shown_content:', task.elements_shown_content);
                
                // Extract and analyze each element
                const allElements = Object.entries(task.elements_shown_content);
                console.log('All elements entries:', allElements);
                
                allElements.forEach(([name, data], index) => {
                    console.log(`Element ${index + 1}:`, {
                        name: name,
                        data: data,
                        type: typeof data,
                        isObject: typeof data === 'object',
                        hasUrl: data && typeof data === 'object' && data.url,
                        zIndex: data && typeof data === 'object' ? data.z_index : 'N/A',
                        layerName: data && typeof data === 'object' ? data.layer_name : 'N/A'
                    });
                });
                
                // Filter valid elements
                const validElements = allElements.filter(([name, data]) => {
                    const isValid = data && data !== 'none' && data !== '' && typeof data === 'object' && data.url;
                    console.log(`Element ${name} valid: ${isValid}`, data);
                    return isValid;
                });
                
                console.log('Valid elements count:', validElements.length);
                
                // Sort elements by z-index to ensure proper layering
                const sortedElements = validElements.sort((a, b) => {
                    // Use actual z-index values from database
                    const zIndexA = a[1].z_index;
                    const zIndexB = b[1].z_index;
                    
                    console.log(`Comparing z-index: ${zIndexA} vs ${zIndexB}`);
                    
                    // Handle undefined z-index values
                    if (zIndexA === undefined && zIndexB === undefined) return 0;
                    if (zIndexA === undefined) return 1; // Put undefined at end
                    if (zIndexB === undefined) return -1; // Put undefined at end
                    
                    return zIndexA - zIndexB; // Sort by z-index ascending
                });
                
                console.log('Final sorted elements:', sortedElements);
                
                sortedElements.forEach(([elementName, elementData], index) => {
                    // Use actual z-index value from database, don't default
                    let zIndex = elementData.z_index;
                    console.log(`Processing element ${index + 1}: ${elementName}, z-index: ${zIndex}, layer: ${elementData.layer_name}`);
                    
                    // Validate z-index
                    if (zIndex === undefined || zIndex === null) {
                        console.warn(`⚠️  Element ${elementName} has no z-index!`);
                        // Fallback: use index as z-index for proper layering
                        zIndex = index;
                        console.log(`🔄 Using fallback z-index: ${zIndex} for ${elementName}`);
                    }
                    
                    // Use preloaded image if available, otherwise fallback to URL
                    const preloadedImg = window.imagePreloader ? window.imagePreloader.getPreloadedImage(elementData.url) : null;
                    const imageSrc = preloadedImg ? preloadedImg.src : elementData.url;
                    
                    imageHTML += `
                        <div class="layer-image" style="z-index: ${zIndex};">
                            <img src="${imageSrc}" 
                                 alt="${elementData.alt_text || elementData.name}" 
                                 class="vignette-layer-img"
                                 data-layer="${elementData.layer_name}"
                                 data-z-index="${zIndex}"
                                 title="${elementName}: ${elementData.layer_name} (z-index: ${zIndex})">
                        </div>
                    `;
                });
                
                imageHTML += '</div>';
            }
        }
        
        return `
           
                <div class="progress-indicator">
                    <div class="task-rectangles">
                        ${this.generateTaskRectangles()}
                    </div>
                   
                </div>
                
                <div class="question-text">
                    {{ study.main_question }}{% if not study.main_question.endswith('?') %}?{% endif %}
                </div>
                

                    ${imageHTML}
     
                <div class="rating-section" style="border: none !important; box-shadow: none !important; background: none !important;">
                    <div class="rating-instructions">
                        <p><strong>{{ study.rating_scale.min_value }} = {{ study.rating_scale.min_label }}</strong></p>
                        {% if study.rating_scale.middle_label %}
                            <p><strong>{{ (study.rating_scale.min_value + study.rating_scale.max_value) // 2 }} = {{ study.rating_scale.middle_label }}</strong></p>
                        {% endif %}
                        <p><strong>{{ study.rating_scale.max_value }} = {{ study.rating_scale.max_label }}</strong></p>
                    </div>
                    
                    <div class="rating-grid">
                        {% for rating in range(study.rating_scale.min_value, study.rating_scale.max_value + 1) %}
                            <div class="rating-option" data-rating="{{ rating }}">
                                <div class="rating-label">
                                    <span class="rating-number">{{ rating }}</span>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            
        `;
    }
    
    initializeRatingSystem() {
        console.log('🔍 Initializing rating system...');
        
        // Ensure we're not submitting when initializing
        if (this.isSubmitting) {
            console.log('⚠️ Already submitting, skipping rating system initialization');
            return;
        }
        
        // Simple, direct approach - no cloning, no complex logic
        const ratingOptions = document.querySelectorAll('.rating-option');
        console.log('🔍 Found rating options:', ratingOptions.length);
        
        if (ratingOptions.length === 0) {
            console.error('❌ No rating options found! Check if rating-section HTML is generated correctly.');
            return;
        }
        
        let selectedRating = null;
        
        // Clear any existing selections
        ratingOptions.forEach(option => {
            const label = option.querySelector('.rating-label');
            if (label) {
                label.classList.remove('active', 'hover');
            }
        });
        
        // DEBUG: Check for overlapping elements specifically for grid studies
        if ('{{ study.study_type }}' === 'grid') {
            console.log('🔍 GRID STUDY DEBUG: Checking for overlapping elements...');
            ratingOptions.forEach((option, index) => {
                const rect = option.getBoundingClientRect();
                const rating = option.dataset.rating;
                console.log(`Rating ${rating}: position=(${rect.left}, ${rect.top}), size=${rect.width}x${rect.height}, z-index=${window.getComputedStyle(option).zIndex}`);
                
                // Check if any other elements are overlapping this rating option
                const overlappingElements = document.elementsFromPoint(rect.left + rect.width/2, rect.top + rect.height/2);
                console.log(`Rating ${rating} overlapping elements:`, overlappingElements.map(el => el.className || el.tagName));
                
                // Force rating option to be on top
                option.style.zIndex = '999';
                option.style.pointerEvents = 'auto';
                option.style.position = 'relative';
                
                // Remove any interfering elements
                overlappingElements.forEach(el => {
                    if (el !== option && !el.classList.contains('rating-option') && !el.classList.contains('rating-label')) {
                        console.log(`⚠️ Found interfering element:`, el.className || el.tagName);
                        el.style.pointerEvents = 'none';
                    }
                });
            });
        }
        
        // Simple event listener setup - exactly like working layer study
        ratingOptions.forEach((option, index) => {
            const rating = option.dataset.rating;
            const label = option.querySelector('.rating-label');
            
            console.log(`🔍 Setting up rating option ${index + 1}: rating=${rating}`);
            
            // Direct click event - simple and reliable
            option.onclick = (event) => {
                console.log('🎯 CLICK EVENT TRIGGERED on rating option:', rating);
                console.log('🎯 Event target:', event.target);
                console.log('🎯 Event currentTarget:', event.currentTarget);
                console.log('🎯 Event type:', event.type);
                console.log('🎯 Event isTrusted:', event.isTrusted);
                console.log('🎯 Current task index:', this.currentTaskIndex);
                console.log('🎯 Is submitting:', this.isSubmitting);
                console.log('🎯 User has interacted:', this.userHasInteracted);
                
                // Mark that user has interacted with the page
                this.userHasInteracted = true;
                
                // Only allow trusted user events
                if (!event.isTrusted) {
                    console.log('⚠️ Non-trusted event, ignoring');
                    return;
                }
                
                if (this.isSubmitting) {
                    console.log('⚠️ Submission in progress, ignoring click');
                    return;
                }
                
                // Check if this task is already completed
                if (this.taskRatings[this.currentTaskIndex]) {
                    console.log('⚠️ Task already completed, ignoring click');
                    return;
                }
                
                console.log('🎯 Rating selected:', rating, 'for task', this.currentTaskIndex + 1);
                selectedRating = parseInt(rating);
                
                // Simple visual feedback
                ratingOptions.forEach(opt => {
                    const optLabel = opt.querySelector('.rating-label');
                    if (optLabel) optLabel.classList.remove('active');
                });
                
                if (label) {
                    label.classList.add('active');
                }
                
                console.log('✅ Visual feedback applied, submitting rating...');
                
                // Submit rating
                this.submitRating(selectedRating);
            };
            
            // Simple hover effects
            if (label) {
                label.onmouseenter = function() {
                    if (!this.classList.contains('active')) {
                        this.classList.add('hover');
                    }
                };
                
                label.onmouseleave = function() {
                    this.classList.remove('hover');
                };
            }
            
            console.log(`✅ Rating option ${index + 1} (${rating}) setup completed`);
        });
        
        console.log('✅ Rating system initialized for', ratingOptions.length, 'options');
        

    }
    
    startTaskTimer() {
        this.taskStartTime = new Date();
        console.log('Task timer started:', this.taskStartTime);
    }
    
    validateZIndexStructure(activeElements) {
        console.log('🔍 Z-Index Structure Validation:');
        
        const zIndexValues = activeElements.map(([name, data]) => data.z_index);
        const uniqueZIndexes = [...new Set(zIndexValues)];
        
        console.log('- All z-index values:', zIndexValues);
        console.log('- Unique z-index values:', uniqueZIndexes.sort((a, b) => a - b));
        
        // Check for missing z-index values
        const missingZIndex = zIndexValues.some(z => z === undefined || z === null);
        if (missingZIndex) {
            console.warn('⚠️  Some elements are missing z-index values!');
        }
        
        // Check for duplicate z-index values
        const duplicateZIndex = uniqueZIndexes.length !== zIndexValues.length;
        if (duplicateZIndex) {
            console.warn('⚠️  Duplicate z-index values detected!');
        }
        
        // Analyze layer names and suggest proper z-index
        console.log('🔍 Layer Name Analysis:');
        activeElements.forEach(([name, data]) => {
            const layerName = data.layer_name;
            const zIndex = data.z_index;
            
            // Suggest proper z-index based on layer name
            let suggestedZIndex = 'Unknown';
            if (layerName.toLowerCase().includes('background')) suggestedZIndex = 0;
            else if (layerName.toLowerCase().includes('middle')) suggestedZIndex = 1;
            else if (layerName.toLowerCase().includes('foreground')) suggestedZIndex = 2;
            else if (layerName.toLowerCase().includes('top')) suggestedZIndex = 3;
            else if (layerName.toLowerCase().includes('front')) suggestedZIndex = 3;
            
            console.log(`  • ${name}: layer="${layerName}", current z-index=${zIndex}, suggested=${suggestedZIndex}`);
        });
        
        console.log(`- Z-index validation: ${missingZIndex ? '❌' : '✅'} Missing values, ${duplicateZIndex ? '❌' : '✅'} Duplicates`);
    }
    
    debugZIndexLayering() {
        console.log('Layer study detected, checking z-index layering...');
        
        const layerImages = document.querySelectorAll('.layer-image');
        console.log('Found layer images:', layerImages.length);
        
        if (layerImages.length === 0) {
            console.warn('⚠️  No layer images found! Check if elements_shown_content has data.');
            return;
        }
        
        layerImages.forEach((layer, index) => {
            const img = layer.querySelector('img');
            const zIndex = layer.style.zIndex;
            const layerName = img.dataset.layer;
            const zIndexData = img.dataset.zIndex;
            
            console.log(`Layer ${index + 1}:`, {
                element: layer,
                zIndex: zIndex,
                layerName: layerName,
                dataZIndex: zIndexData,
                imgSrc: img.src,
                computedZIndex: window.getComputedStyle(layer).zIndex
            });
            
            // Ensure z-index is properly set
            if (zIndex && zIndex !== 'auto') {
                layer.style.zIndex = zIndex;
                console.log(`✅ Set z-index for layer ${index + 1} to: ${zIndex}`);
            } else {
                console.warn(`⚠️  Layer ${index + 1} has no z-index set: ${zIndex}`);
            }
        });
        
        // Log the stacking order
        console.log('📋 Final stacking order (lowest to highest z-index):');
        const sortedLayers = Array.from(layerImages).sort((a, b) => {
            const zA = parseInt(a.style.zIndex) || 0;
            const zB = parseInt(b.style.zIndex) || 0;
            return zA - zB;
        });
        
        sortedLayers.forEach((layer, index) => {
            const img = layer.querySelector('img');
            const zIndex = layer.style.zIndex;
            const layerName = img.dataset.layer;
            console.log(`  ${index + 1}. ${layerName} (z-index: ${zIndex})`);
        });
    }
    
    async submitRating(rating) {
        if (this.isSubmitting) {
            console.log('⚠️ Already submitting, ignoring submitRating call');
            return;
        }
        
        console.log('🚀 submitRating called with rating:', rating);
        console.log('🚀 Current task index:', this.currentTaskIndex);
        console.log('🚀 Total tasks:', this.totalTasks);
        console.log('🚀 Is submitting flag:', this.isSubmitting);
        
        this.isSubmitting = true;
        const taskEndTime = new Date();
        const taskDuration = (taskEndTime - this.taskStartTime) / 1000;
        
        console.log('Submitting rating:', rating, 'Duration:', taskDuration);
        
        // Create task data with comprehensive information
        const currentTask = this.allTasks[this.currentTaskIndex];
        console.log('📋 Current task data for submission:', currentTask);
        
        const taskData = {
            task_number: this.currentTaskIndex + 1,
            rating: rating,
            timestamp: taskEndTime.toISOString(),
            task_start_time: this.taskStartTime.toISOString(),
            task_end_time: taskEndTime.toISOString(),
            task_duration_seconds: taskDuration,
            task_data: {
                // Grid study data
                elements_shown: currentTask.elements_shown || {},
                // Layer study data
                elements_shown_content: currentTask.elements_shown_content || {},
                // Task metadata
                task_type: currentTask.task_type || '{{ study.study_type }}',
                task_index: this.currentTaskIndex,
                // Element interactions (if available)
                element_interactions: currentTask.element_interactions || [],
                // Additional task context
                task_context: {
                    study_type: '{{ study.study_type }}',
                    total_elements: currentTask.total_elements || 0,
                    active_elements: currentTask.active_elements || 0
                }
            }
        };
        
        console.log('📤 Submitting comprehensive task data:', taskData);
        
        // Store task rating
        this.taskRatings[this.currentTaskIndex] = taskData;
        
        // Check if this is the last task
        if (this.currentTaskIndex === this.totalTasks - 1) {
            console.log('🎯 Last task completed - starting completion process...');
            // Show completion loader for last task
            this.showCompletionLoader();
            // Start the completion process
            this.completeStudy();
        } else {
            // ADVANCE TO NEXT TASK
            console.log('⚡ Advancing to next task...');
            this.currentTaskIndex++; // Move to next task
            console.log(`✅ Moved to task ${this.currentTaskIndex + 1} (index: ${this.currentTaskIndex})`);
            
            // Show the next task immediately
            this.showTask(this.currentTaskIndex);
        }
    }
    
    showRatingFeedback() {
        const feedback = document.getElementById('ratingFeedback');
        feedback.classList.add('show');
        
        setTimeout(() => {
            feedback.classList.remove('show');
        }, 800);
    }
    
    showCompletionLoader() {
        console.log('🔄 Showing completion loader for last task...');
        const loader = document.getElementById('completionLoader');
        loader.classList.add('show');
    }
    
    hideCompletionLoader() {
        console.log('✅ Hiding completion loader...');
        const loader = document.getElementById('completionLoader');
        loader.classList.remove('show');
    }
    
    
    updateNavigation() {
        // Navigation is now handled by the progress bar
        // No need to update individual buttons
        console.log(`Navigation updated - Current task: ${this.currentTaskIndex + 1}`);
    }
    
    generateTaskRectangles() {
        let rectanglesHTML = '';
        for (let i = 0; i < this.totalTasks; i++) {
            let className = 'task-rectangle';
            if (i < this.currentTaskIndex) {
                className += ' completed';
            } else if (i === this.currentTaskIndex) {
                className += ' current';
            } else {
                className += ' upcoming';
            }
            rectanglesHTML += `<div class="${className}" data-task="${i + 1}"></div>`;
        }
        return rectanglesHTML;
    }
    
    calculateProgressPercentage() {
        return ((this.currentTaskIndex + 1) / this.totalTasks) * 100;
    }
    
    updateProgress() {
        const progress = this.calculateProgressPercentage();
        
        console.log(`🔄 Updating progress: ${progress}% - Task ${this.currentTaskIndex + 1} of ${this.totalTasks}`);
        
        // Update task rectangles to show current progress
        const progressIndicator = document.querySelector('.progress-indicator');
        if (progressIndicator) {
            const taskRectangles = progressIndicator.querySelector('.task-rectangles');
            if (taskRectangles) {
                // Regenerate rectangles with updated state
                taskRectangles.innerHTML = this.generateTaskRectangles();
                console.log(`🎯 Task rectangles updated - Current task: ${this.currentTaskIndex + 1}`);
            } else {
                console.warn('⚠️  Task rectangles container not found');
            }
        } else {
            console.warn('⚠️  Progress indicator element not found');
        }
    }
    
    saveToLocalStorage() {
        const data = {
            studyId: this.studyId,
            currentTaskIndex: this.currentTaskIndex,
            taskRatings: this.taskRatings,
            progressPercentage: this.calculateProgressPercentage(), // Save progress percentage
            timestamp: new Date().toISOString()
        };
        
        localStorage.setItem(`study_${this.studyId}_progress`, JSON.stringify(data));
        console.log('💾 Progress saved to local storage:', data);
    }
    
    clearAllLocalStorage() {
        console.log('🗑️ Clearing all study-related localStorage data...');
        
        // Clear study progress
        localStorage.removeItem(`study_${this.studyId}_progress`);
        
        // Clear image preloader cache
        if (window.imagePreloader && window.imagePreloader.cacheKey) {
            localStorage.removeItem(window.imagePreloader.cacheKey);
        }
        
        // Clear any other study-related localStorage items
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.includes(this.studyId)) {
                keysToRemove.push(key);
            }
        }
        
        keysToRemove.forEach(key => {
            localStorage.removeItem(key);
            console.log(`🗑️ Removed localStorage key: ${key}`);
        });
        
        console.log('✅ All study-related localStorage data cleared');
    }
    
    loadFromLocalStorage() {
        const saved = localStorage.getItem(`study_${this.studyId}_progress`);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.studyId === this.studyId) {
                    // Restore the exact task index from localStorage
                    this.currentTaskIndex = data.currentTaskIndex || 0;
                    this.taskRatings = data.taskRatings || [];
                    console.log('💾 Progress loaded from local storage:', data);
                    console.log(`🎯 Restored to task ${this.currentTaskIndex + 1} of ${this.totalTasks}`);
                    
                    // Validate that the restored task index is valid
                    if (this.currentTaskIndex >= this.totalTasks) {
                        console.warn('⚠️ Restored task index is beyond total tasks, resetting to 0');
                        this.currentTaskIndex = 0;
                    }
                    
                    // Check if all tasks are completed
                    if (this.taskRatings.length >= this.totalTasks) {
                        console.log('🎉 All tasks appear to be completed, redirecting to completion page');
                        window.location.href = `/study/${this.studyId}/completed`;
                        return;
                    }
                    
                    // Update progress bar to reflect the restored task index
                    this.updateProgress();
                }
            } catch (e) {
                console.log('Could not load saved progress:', e);
                this.currentTaskIndex = 0;
                this.taskRatings = [];
            }
        } else {
            console.log('No saved progress found, starting from task 1');
            this.currentTaskIndex = 0;
            this.taskRatings = [];
        }
    }
    
    
    async completeStudy() {
        console.log('🎉 All tasks completed! Starting completion process...');
        
        // Add timeout protection to prevent infinite loading
        const completionTimeout = setTimeout(() => {
            console.warn('⚠️  Completion process taking too long, forcing redirect...');
            this.hideCompletionLoader();
            window.location.href = `/study/${this.studyId}/completed`;
        }, 15000); // 15 second timeout
        
        try {
            // Update loader text to show completion progress
            const loaderText = document.querySelector('#completionLoader .loader-text');
            const loaderSubtext = document.querySelector('#completionLoader .loader-subtext');
            
            if (loaderText && loaderSubtext) {
                loaderText.textContent = 'Task Complete!';
                loaderSubtext.textContent = 'Thank you for completing all tasks. Saving your responses...';
            }
            
            // Submit all ratings to server
            console.log('📤 Submitting all task ratings to server...');
            console.log('📊 Task ratings to submit:', this.taskRatings);
            
            const response = await fetch(`/study/${this.studyId}/submit-all-ratings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                },
                body: JSON.stringify({
                    task_ratings: this.taskRatings
                })
            });
            
            console.log('📡 Server response status:', response.status);
            
            if (response.ok) {
                console.log('✅ All ratings submitted successfully!');
                
                // Clear timeout since we're successful
                clearTimeout(completionTimeout);
                
                // Update loader text for final step
                if (loaderText && loaderSubtext) {
                    loaderText.textContent = 'Responses Saved!';
                    loaderSubtext.textContent = 'Redirecting you to the completion page...';
                }
                
                // Clear study progress from localStorage
                localStorage.removeItem(`study_${this.studyId}_progress`);
                
                // Redirect to completion page after showing success message
                setTimeout(() => {
                    console.log('🚀 Redirecting to completion page...');
                    window.location.href = `/study/${this.studyId}/completed`;
                }, 2000);
                
            } else {
                const errorText = await response.text();
                console.error('❌ Server error response:', errorText);
                throw new Error(`Server error: ${response.status} - ${errorText}`);
            }
        } catch (error) {
            console.error('❌ Error submitting ratings:', error);
            
            // Clear timeout
            clearTimeout(completionTimeout);
            
            // Hide loader and show error
            this.hideCompletionLoader();
            alert('Error submitting ratings. Please try again or contact support.');
        }
    }
    
    debugOverlappingElements() {
        console.log('🔍 Checking for overlapping elements that might block clicks...');
        
        const ratingOptions = document.querySelectorAll('.rating-option');
        const ratingSection = document.querySelector('.rating-section');
        
        if (ratingSection) {
            const rect = ratingSection.getBoundingClientRect();
            console.log('🔍 Rating section position:', {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                zIndex: window.getComputedStyle(ratingSection).zIndex
            });
        }
        
        ratingOptions.forEach((option, index) => {
            const rect = option.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(option);
            
            console.log(`🔍 Rating option ${index + 1} (${option.dataset.rating}):`, {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                zIndex: computedStyle.zIndex,
                pointerEvents: computedStyle.pointerEvents,
                position: computedStyle.position,
                display: computedStyle.display,
                visibility: computedStyle.visibility
            });
            
            // Check if there are any elements overlapping this rating option
            const elementsAtPoint = document.elementsFromPoint(
                rect.left + rect.width / 2,
                rect.top + rect.height / 2
            );
            
            console.log(`🔍 Elements at rating option ${index + 1} center:`, elementsAtPoint.map(el => ({
                tagName: el.tagName,
                className: el.className,
                id: el.element_id,
                zIndex: window.getComputedStyle(el).zIndex
            })));
        });
    }
    
    debugGridStudyStructure() {
        console.log('🔍 GRID STUDY STRUCTURE DEBUG:');
        
        // Check grid elements container
        const gridContainer = document.querySelector('.grid-elements-container');
        if (gridContainer) {
            const rect = gridContainer.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(gridContainer);
            
            console.log('🔍 Grid container:', {
                exists: true,
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                display: computedStyle.display,
                position: computedStyle.position,
                zIndex: computedStyle.zIndex,
                overflow: computedStyle.overflow
            });
        } else {
            console.log('❌ Grid container not found!');
        }
        
        // Check grid element items
        const gridItems = document.querySelectorAll('.grid-element-item');
        console.log(`🔍 Grid items found: ${gridItems.length}`);
        
        gridItems.forEach((item, index) => {
            const rect = item.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(item);
            
            console.log(`🔍 Grid item ${index + 1}:`, {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                display: computedStyle.display,
                position: computedStyle.position,
                zIndex: computedStyle.zIndex
            });
        });
        
        // Check if grid elements are interfering with rating system
        const ratingSection = document.querySelector('.rating-section');
        if (ratingSection && gridContainer) {
            const ratingRect = ratingSection.getBoundingClientRect();
            const gridRect = gridContainer.getBoundingClientRect();
            
            console.log('🔍 Layout analysis:', {
                ratingSectionTop: ratingRect.top,
                ratingSectionBottom: ratingRect.bottom,
                gridContainerTop: gridRect.top,
                gridContainerBottom: gridRect.bottom,
                overlap: !(ratingRect.bottom < gridRect.top || ratingRect.top > gridRect.bottom)
            });
        }
    }
    
    testRatingSystem() {
        console.log('🧪 Testing rating system functionality...');
        
        // Check if rating options exist
        const ratingOptions = document.querySelectorAll('.rating-option');
        console.log('🧪 Rating options found:', ratingOptions.length);
        
        if (ratingOptions.length === 0) {
            console.error('🧪 ❌ No rating options found for testing!');
            return;
        }
        
        // Test each rating option
        ratingOptions.forEach((option, index) => {
            const rating = option.dataset.rating;
            const label = option.querySelector('.rating-label');
            
            console.log(`🧪 Rating option ${index + 1} (${rating}):`, {
                exists: !!option,
                hasDataset: !!option.dataset.rating,
                hasLabel: !!label,
                labelText: label ? label.textContent : 'N/A',
                isClickable: option.style.pointerEvents !== 'none',
                zIndex: window.getComputedStyle(option).zIndex,
                position: window.getComputedStyle(option).position
            });
            
            // Test if element is actually clickable
            const rect = option.getBoundingClientRect();
            console.log(`🧪 Rating option ${index + 1} position:`, {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height,
                visible: rect.width > 0 && rect.height > 0
            });
        });
        
        // Test if any elements are overlapping the rating options
        const ratingSection = document.querySelector('.rating-section');
        if (ratingSection) {
            const ratingRect = ratingSection.getBoundingClientRect();
            console.log('🧪 Rating section bounds:', {
                top: ratingRect.top,
                left: ratingRect.left,
                width: ratingRect.width,
                height: ratingRect.height
            });
            
            // Check for overlapping elements
            const centerX = ratingRect.left + ratingRect.width / 2;
            const centerY = ratingRect.top + ratingRect.height / 2;
            const elementsAtCenter = document.elementsFromPoint(centerX, centerY);
            
            console.log('🧪 Elements at rating section center:', elementsAtCenter.map(el => ({
                tagName: el.tagName,
                className: el.className,
                id: el.element_id
            })));
        }
        
        console.log('🧪 Rating system test completed');
    }
}

// Initialize lightning-fast task flow when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 DOM Content Loaded - Starting initialization...');
    
    // Calculate and apply proper screen dimensions
    function calculateScreenDimensions() {
        const vh = window.innerHeight * 0.01;
        const vw = window.innerWidth * 0.01;
        
        console.log('📱 Screen dimensions:', {
            innerHeight: window.innerHeight,
            innerWidth: window.innerWidth,
            vh: vh,
            vw: vw
        });
        
        // Set CSS custom properties for dynamic sizing
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        document.documentElement.style.setProperty('--vw', `${vw}px`);
        
        // Apply calculated heights to prevent scrolling
        const body = document.body;
        const html = document.documentElement;
        const mainContent = document.getElementById('main-content');
        const taskContainer = document.getElementById('taskContainer');
        
        if (body) body.style.height = `${window.innerHeight}px`;
        if (html) html.style.height = `${window.innerHeight}px`;
        if (mainContent) mainContent.style.height = `${window.innerHeight}px`;
        if (taskContainer) taskContainer.style.height = `${window.innerHeight}px`;
        
        console.log('✅ Screen dimensions applied');
    }
    
    // Calculate dimensions on load and resize
    calculateScreenDimensions();
    window.addEventListener('resize', calculateScreenDimensions);
    window.addEventListener('orientationchange', () => {
        setTimeout(calculateScreenDimensions, 100);
    });
    
    // Check if required elements exist
    const taskContainer = document.getElementById('taskContainer');
    
    if (!taskContainer) {
        console.error('❌ CRITICAL: taskContainer element not found!');
        return;
    }
    
    const studyId = '{{ study._id }}';
    const totalTasks = {{ total_tasks }};
    const allTasks = {{ all_tasks|tojson|safe }};
    
    // Initialize study data for template access
    window.studyData = {
        study_type: '{{ study.study_type }}',
        default_background: {{ study.default_background | tojson if study.default_background else 'null' }}
    };
    
    console.log('🚀 Initializing Lightning Task Flow...');
    console.log('Study ID:', studyId);
    console.log('Total Tasks:', totalTasks);
    console.log('All Tasks:', allTasks);
    console.log('Study Data:', window.studyData);
    
    // Start tasks immediately - countdown will handle the timing
    console.log('🚀 Starting task flow immediately...');
    startTaskFlow();
    

    
    function startTaskFlow() {
        // Create and start the lightning-fast task flow
        try {
            window.taskFlow = new LightningTaskFlow(studyId, totalTasks, allTasks);
            console.log('✅ LightningTaskFlow initialized successfully!');
        } catch (error) {
            console.error('❌ Error initializing LightningTaskFlow:', error);
        }
        
        // Save progress before page unload (refresh, close, etc.)
        window.addEventListener('beforeunload', () => {
            if (window.taskFlow) {
                console.log('💾 Saving progress before page unload...');
                window.taskFlow.saveToLocalStorage();
            }
        });
        
        // Save progress when page becomes hidden (mobile app switching, etc.)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && window.taskFlow) {
                console.log('💾 Saving progress - page hidden...');
                window.taskFlow.saveToLocalStorage();
            }
        });
    }
});
</script>
{% endblock %}

